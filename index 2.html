<!DOCTYPE html>
<html lang="en">

<head>
    <title>Cyandev&#x27;s Blog</title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <meta name="robots" content="noodp"/>

    <link rel="stylesheet" href="https://unixzii.github.io/style.css">
    <link rel="stylesheet" href="https://unixzii.github.io/color/orange.css">

        <link rel="stylesheet" href="https://unixzii.github.io/color/background_blue.css">
    
    <link rel="stylesheet" href="https://unixzii.github.io/font-hack-subset.css">

    </head>

<body class="">
<div class="container">
    
    

    <aside class="aside">
        <div class="adaptive-container">
            <div class="aside__logo">
                <!-- Customized logo area (will not be affected by config) -->
                <strong>Cyandev's</strong>
                <br>
                <span style="font-weight: 100;">Blog</span>
            </div>
            <div class="aside__menu">
                
                    
                <nav class="menu">
            <ul class="menu__inner">
                <li class="active"><a href="https://unixzii.github.io">posts</a></li>
            
                <li><a href="https://unixzii.github.io/archive">archive</a></li>
            
                <li><a href="https://unixzii.github.io/tags">tags</a></li>
            
                <li><a href="https://unixzii.github.io/about">about</a></li>
            </ul>
        </nav>
    
    
                
            </div>
        </div>
    </aside>

    <div class="content">
        
        <div class="posts">
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://unixzii.github.io/why-objc-properties-need-atomic/">为什么 Objective-C 的属性还需要 atomic</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2022-07-27
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://unixzii.github.io/tags/rust/">#rust</a>&nbsp;
                <a class="post-tag" href="https://unixzii.github.io/tags/concurrency/">#concurrency</a>&nbsp;
                <a class="post-tag" href="https://unixzii.github.io/tags/why-x/">#why-x</a></span>
    

                    
        <div class="post-content">
            <p>使用过 Objective-C 的朋友们应该都知道，将一个属性声明为 <code>atomic</code> 并不能解决可变对象的多线程问题。既然如此，那么这个属性存在的意义是什么呢？本文将对比多个支持引用计数的编程语言，聊聊这个古老话题的“底层逻辑”。</p>
<p>我们知道，<code>atomic</code> 和 <code>nonatomic</code> 主要针对对象类型的属性，对于原始类型没有影响。而对于对象类型的属性，在使用 <code>nonatomic</code> 的情况下，需要保证不存在多个线程同时<strong>读写</strong>这个属性，否则就会产生 crash。对象类型和原始类型在属性读写上有什么区别呢？答案就是引用计数。对于下面的代码：</p>
<pre data-lang="objective-c" style="background-color:#2b303b;color:#c0c5ce;" class="language-objective-c "><code class="language-objective-c" data-lang="objective-c"><span style="color:#b48ead;">@interface </span><span>SomeObject </span><span style="color:#8fa1b3;">: </span><span style="color:#a3be8c;">NSObject
</span><span>
</span><span style="color:#b48ead;">@property </span><span>(</span><span style="color:#b48ead;">nonatomic</span><span>, </span><span style="color:#b48ead;">strong</span><span>) </span><span style="color:#ebcb8b;">NSObject </span><span>*someProperty;
</span><span>
</span><span style="color:#b48ead;">@end
</span></code></pre>
<p>我们来看看编译器为其生成的 setter 方法（由于是生成方法，这里只会有汇编代码）：</p>
<pre data-lang="asm" style="background-color:#2b303b;color:#c0c5ce;" class="language-asm "><code class="language-asm" data-lang="asm"><span>-[</span><span style="color:#8fa1b3;">SomeObject setSomeProperty:</span><span>]</span><span style="color:#8fa1b3;">:
</span><span style="color:#8fa1b3;">    pushq  %</span><span style="color:#bf616a;">rbp
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rsp</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rbp
</span><span style="color:#8fa1b3;">    subq   </span><span style="color:#96b5b4;">$</span><span style="color:#d08770;">0x20</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rsp
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rdi</span><span>, -</span><span style="color:#d08770;">0x8</span><span style="color:#8fa1b3;">(%</span><span style="color:#bf616a;">rbp</span><span style="color:#8fa1b3;">)
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rsi</span><span>, -</span><span style="color:#d08770;">0x10</span><span style="color:#8fa1b3;">(%</span><span style="color:#bf616a;">rbp</span><span style="color:#8fa1b3;">)
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rdx</span><span>, -</span><span style="color:#d08770;">0x18</span><span style="color:#8fa1b3;">(%</span><span style="color:#bf616a;">rbp</span><span style="color:#8fa1b3;">)
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span>-</span><span style="color:#d08770;">0x18</span><span style="color:#8fa1b3;">(%</span><span style="color:#bf616a;">rbp</span><span style="color:#8fa1b3;">)</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rsi
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span>-</span><span style="color:#d08770;">0x8</span><span style="color:#8fa1b3;">(%</span><span style="color:#bf616a;">rbp</span><span style="color:#8fa1b3;">)</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rdi
</span><span style="color:#8fa1b3;">    addq   </span><span style="color:#96b5b4;">$</span><span style="color:#d08770;">0x8</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rdi
</span><span style="color:#8fa1b3;">    callq  objc_storeStrong</span><span style="color:#65737e;">  ; 关键函数
</span><span style="color:#8fa1b3;">    addq   </span><span style="color:#96b5b4;">$</span><span style="color:#d08770;">0x20</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rsp
</span><span style="color:#8fa1b3;">    popq   %</span><span style="color:#bf616a;">rbp
</span><span style="color:#8fa1b3;">    retq
</span></code></pre>
<p>我们注意到，对于 <code>nonatomic</code> 属性来说，编译器生成的代码与栈上变量赋值相同，都是 <code>objc_storeStrong</code> 这个 runtime 函数。我们在 objc 源码中可以找到这个函数的实现：</p>
<pre data-lang="objective-c" style="background-color:#2b303b;color:#c0c5ce;" class="language-objective-c "><code class="language-objective-c" data-lang="objective-c"><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">objc_storeStrong</span><span>(</span><span style="color:#b48ead;">id </span><span>*</span><span style="color:#bf616a;">location</span><span>, </span><span style="color:#b48ead;">id </span><span style="color:#bf616a;">obj</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">id </span><span>prev = *location;
</span><span>    </span><span style="color:#b48ead;">if </span><span>(obj == prev) {
</span><span>        </span><span style="color:#b48ead;">return</span><span>;
</span><span>    }
</span><span>    </span><span style="color:#bf616a;">objc_retain</span><span>(obj);
</span><span>    *location = obj;
</span><span>    </span><span style="color:#bf616a;">objc_release</span><span>(prev);
</span><span>}
</span></code></pre>
<p>这段代码中包含了多处操作，包括内存读写和应用计数操作，多线程执行过程中的交错点也是十分多。最典型的例子就是：两个线程均读取 <code>location</code> 到 <code>prev</code>，然后分别进行后续操作，导致的结果就是同一个对象被释放多次，从而产生悬挂指针。</p>
<p>接下来我们来看看相同的场景，将属性换成 <code>atomic</code>，在生成代码上会有什么变化：</p>
<pre data-lang="asm" style="background-color:#2b303b;color:#c0c5ce;" class="language-asm "><code class="language-asm" data-lang="asm"><span>-[</span><span style="color:#8fa1b3;">SomeObject setSomeProperty:</span><span>]</span><span style="color:#8fa1b3;">:
</span><span style="color:#8fa1b3;">    pushq  %</span><span style="color:#bf616a;">rbp
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rsp</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rbp
</span><span style="color:#8fa1b3;">    subq   </span><span style="color:#96b5b4;">$</span><span style="color:#d08770;">0x20</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rsp
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rdi</span><span>, -</span><span style="color:#d08770;">0x8</span><span style="color:#8fa1b3;">(%</span><span style="color:#bf616a;">rbp</span><span style="color:#8fa1b3;">)
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rsi</span><span>, -</span><span style="color:#d08770;">0x10</span><span style="color:#8fa1b3;">(%</span><span style="color:#bf616a;">rbp</span><span style="color:#8fa1b3;">)
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rdx</span><span>, -</span><span style="color:#d08770;">0x18</span><span style="color:#8fa1b3;">(%</span><span style="color:#bf616a;">rbp</span><span style="color:#8fa1b3;">)
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span>-</span><span style="color:#d08770;">0x10</span><span style="color:#8fa1b3;">(%</span><span style="color:#bf616a;">rbp</span><span style="color:#8fa1b3;">)</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rsi
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span>-</span><span style="color:#d08770;">0x8</span><span style="color:#8fa1b3;">(%</span><span style="color:#bf616a;">rbp</span><span style="color:#8fa1b3;">)</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rdi
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span>-</span><span style="color:#d08770;">0x18</span><span style="color:#8fa1b3;">(%</span><span style="color:#bf616a;">rbp</span><span style="color:#8fa1b3;">)</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rdx
</span><span style="color:#8fa1b3;">    movl   </span><span style="color:#96b5b4;">$</span><span style="color:#d08770;">0x8</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">ecx
</span><span style="color:#8fa1b3;">    callq  objc_setProperty_atomic</span><span style="color:#65737e;">  ; 关键函数
</span><span style="color:#8fa1b3;">    addq   </span><span style="color:#96b5b4;">$</span><span style="color:#d08770;">0x20</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rsp
</span><span style="color:#8fa1b3;">    popq   %</span><span style="color:#bf616a;">rbp
</span><span style="color:#8fa1b3;">    retq
</span></code></pre>
<p>可以看到，关键函数变成了 <code>objc_setProperty_atomic</code>，这个函数的实现同样可以在源码中找到：</p>
<pre data-lang="objective-c" style="background-color:#2b303b;color:#c0c5ce;" class="language-objective-c "><code class="language-objective-c" data-lang="objective-c"><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">objc_setProperty_atomic</span><span>(</span><span style="color:#b48ead;">id </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#b48ead;">SEL </span><span style="color:#bf616a;">_cmd</span><span>, </span><span style="color:#b48ead;">id </span><span style="color:#bf616a;">newValue</span><span>, ptrdiff_t </span><span style="color:#bf616a;">offset</span><span>)
</span><span>{
</span><span>    </span><span style="color:#bf616a;">reallySetProperty</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">_cmd</span><span>, newValue, offset, </span><span style="color:#d08770;">true</span><span>, </span><span style="color:#d08770;">false</span><span>, </span><span style="color:#d08770;">false</span><span>);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">static inline void </span><span style="color:#8fa1b3;">reallySetProperty</span><span>(</span><span style="color:#b48ead;">id </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#b48ead;">SEL </span><span style="color:#bf616a;">_cmd</span><span>, </span><span style="color:#b48ead;">id </span><span style="color:#bf616a;">newValue</span><span>, ptrdiff_t </span><span style="color:#bf616a;">offset</span><span>, </span><span style="color:#b48ead;">bool </span><span style="color:#bf616a;">atomic</span><span>, </span><span style="color:#b48ead;">bool </span><span style="color:#bf616a;">copy</span><span>, </span><span style="color:#b48ead;">bool </span><span style="color:#bf616a;">mutableCopy</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">if </span><span>(offset == </span><span style="color:#d08770;">0</span><span>) {
</span><span>        </span><span style="color:#bf616a;">object_setClass</span><span>(</span><span style="color:#bf616a;">self</span><span>, newValue);
</span><span>        </span><span style="color:#b48ead;">return</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">id </span><span>oldValue;
</span><span>    </span><span style="color:#b48ead;">id </span><span>*slot = (</span><span style="color:#b48ead;">id</span><span>*) ((</span><span style="color:#b48ead;">char</span><span>*)</span><span style="color:#bf616a;">self </span><span>+ offset);
</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(copy) {
</span><span>        newValue = [newValue </span><span style="color:#8fa1b3;">copyWithZone:</span><span style="color:#d08770;">nil</span><span>];
</span><span>    } </span><span style="color:#b48ead;">else if </span><span>(mutableCopy) {
</span><span>        newValue = [newValue </span><span style="color:#8fa1b3;">mutableCopyWithZone:</span><span style="color:#d08770;">nil</span><span>];
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>        </span><span style="color:#b48ead;">if </span><span>(*slot == newValue) </span><span style="color:#b48ead;">return</span><span>;
</span><span>        newValue = </span><span style="color:#bf616a;">objc_retain</span><span>(newValue);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(!atomic) {
</span><span>        oldValue = *slot;
</span><span>        *slot = newValue;
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>        spinlock_t&amp; slotlock = PropertyLocks[slot];
</span><span>        slotlock.</span><span style="color:#bf616a;">lock</span><span>();
</span><span>        oldValue = *slot;
</span><span>        *slot = newValue;
</span><span>        slotlock.</span><span style="color:#bf616a;">unlock</span><span>();
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#bf616a;">objc_release</span><span>(oldValue);
</span><span>}
</span></code></pre>
<p>Runtime 在解决这个问题上也十分简单，我们只需要保证属性指针的修改和旧值的获取是一个原子操作即可。这里的原子化使用的是自旋锁，同时为了避免并发度较高的情况下，锁竞争严重，使用了一个全局的 <code>StripedMap</code> 来优化，这个也是很常见的优化手段了。这里其实也可以使用 CAS 操作来取代加锁操作，不过性能上是否真的有提升还需要验证。</p>
<p>为什么最后的 <code>objc_release</code> 不需要在锁的临界区呢？我们知道 <code>nonatomic</code> 产生问题的原因是多个线程同时获取到属性旧值并进行 release；而在 <code>atomic</code> 下，属性旧值获取的同时，新值就被设置了，不存在两个线程获取到同一个旧值的情况。而引用计数的增减，本身也是原子操作，所以对于所有权明确的场景下不需要额外加锁。</p>
<h1 id="qi-ta-yu-yan-zhong-de-yin-yong-ji-shu-zhi-chi">其他语言中的引用计数支持</h1>
<h2 id="c-zhong-de-qing-kuang-clang-stl">C++ 中的情况 (clang STL)</h2>
<p>既然 Objective-C 通过 <code>atomic</code> 属性完美解决了这个问题，C++ 中是否会存在类似的问题呢？我们也使用如下的代码来验证一下：</p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">struct </span><span>SomeObject {
</span><span>    std::shared_ptr&lt;std::string&gt; someProperty;
</span><span>};
</span></code></pre>
<p>在多线程下同时读写 <code>someProperty</code> 字段也发生了 crash，这也就是说 Objective-C 中的 <code>nonatomic</code> 并不是一种性能优化。正如 <code>@synchronized</code> 一样，<code>atomic</code> 实际上是 Objective-C 提供给我们的额外能力，方便处理这种多线程场景。</p>
<p>在 C++ 中的 crash 原因与 Objective-C 中的 <code>nonatomic</code> 非常相似，我们也来看一下对 <code>someProperty</code> 赋值的过程发生了什么。我这里写了一个赋值函数：</p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">writeProperty</span><span>(SomeObject *</span><span style="color:#bf616a;">obj</span><span>, std::shared_ptr&lt;std::string&gt; &amp;&amp;</span><span style="color:#bf616a;">val</span><span>) {
</span><span>    obj-&gt;</span><span style="color:#bf616a;">someProperty </span><span>= std::</span><span style="color:#bf616a;">move</span><span>(val);
</span><span>}
</span></code></pre>
<p>其汇编如下：</p>
<pre data-lang="asm" style="background-color:#2b303b;color:#c0c5ce;" class="language-asm "><code class="language-asm" data-lang="asm"><span style="color:#8fa1b3;">writeProperty:
</span><span style="color:#8fa1b3;">    pushq  %</span><span style="color:#bf616a;">rbp
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rsp</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rbp
</span><span style="color:#8fa1b3;">    subq   </span><span style="color:#96b5b4;">$</span><span style="color:#d08770;">0x10</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rsp
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rdi</span><span>, -</span><span style="color:#d08770;">0x8</span><span style="color:#8fa1b3;">(%</span><span style="color:#bf616a;">rbp</span><span style="color:#8fa1b3;">)
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rsi</span><span>, -</span><span style="color:#d08770;">0x10</span><span style="color:#8fa1b3;">(%</span><span style="color:#bf616a;">rbp</span><span style="color:#8fa1b3;">)
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span>-</span><span style="color:#d08770;">0x10</span><span style="color:#8fa1b3;">(%</span><span style="color:#bf616a;">rbp</span><span style="color:#8fa1b3;">)</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rdi
</span><span style="color:#8fa1b3;">    callq  </span><span style="color:#b48ead;">std</span><span style="color:#8fa1b3;">::__1::move&lt;</span><span style="color:#b48ead;">std</span><span style="color:#8fa1b3;">::__1::shared_ptr&lt;</span><span style="color:#b48ead;">std</span><span style="color:#8fa1b3;">::__1::basic_string&lt;char</span><span>, </span><span style="color:#b48ead;">std</span><span style="color:#8fa1b3;">::__1::char_traits&lt;char&gt;</span><span>, </span><span style="color:#8fa1b3;">&lt;char&gt; &gt; &gt;&amp;&gt; </span><span style="color:#96b5b4;">at </span><span style="color:#8fa1b3;">move.h:</span><span style="color:#d08770;">27
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rax</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rsi
</span><span style="color:#8fa1b3;">    </span><span style="color:#b48ead;">movq   </span><span>-</span><span style="color:#d08770;">0x8</span><span style="color:#8fa1b3;">(%</span><span style="color:#bf616a;">rbp</span><span style="color:#8fa1b3;">)</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rdi
</span><span style="color:#65737e;">    ; 关键方法:
</span><span style="color:#8fa1b3;">    callq  </span><span style="color:#b48ead;">std</span><span style="color:#8fa1b3;">::__1::shared_ptr&lt;</span><span style="color:#b48ead;">std</span><span style="color:#8fa1b3;">::__1::basic_string&lt;char</span><span>, </span><span style="color:#b48ead;">std</span><span style="color:#8fa1b3;">::__1::char_traits&lt;char&gt;</span><span>, </span><span style="color:#b48ead;">std</span><span style="color:#8fa1b3;">::__1::allocator&lt;char&gt; &gt; red_ptr.h:</span><span style="color:#d08770;">989
</span><span style="color:#8fa1b3;">    addq   </span><span style="color:#96b5b4;">$</span><span style="color:#d08770;">0x10</span><span>, </span><span style="color:#8fa1b3;">%</span><span style="color:#bf616a;">rsp
</span><span style="color:#8fa1b3;">    popq   %</span><span style="color:#bf616a;">rbp
</span><span style="color:#8fa1b3;">    retq
</span></code></pre>
<p>由于 C++ 支持 <code>operator=</code> 来自定义对象赋值操作，因此简单的赋值表达式其实也是一个函数调用，这里展示的是 inline 之后的结果。而 <code>std::move</code> 是一个 cast 操作，对值内容其实没有任何影响，我们可以直接分析其中的关键方法。这个方法的符号在编译时被模板展开了，实际上对应的是 <code>std::shared_ptr</code> 如下方法：</p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">template</span><span>&lt;</span><span style="color:#b48ead;">class</span><span> _Tp&gt;
</span><span style="color:#b48ead;">inline
</span><span>shared_ptr&lt;_Tp&gt;&amp;
</span><span>shared_ptr&lt;_Tp&gt;::</span><span style="color:#8fa1b3;">operator=</span><span>(shared_ptr&amp;&amp; </span><span style="color:#bf616a;">__r</span><span>) _NOEXCEPT
</span><span>{
</span><span>    </span><span style="color:#bf616a;">shared_ptr</span><span>(_VSTD::</span><span style="color:#bf616a;">move</span><span>(__r)).</span><span style="color:#bf616a;">swap</span><span>(*</span><span style="color:#bf616a;">this</span><span>);
</span><span>    </span><span style="color:#b48ead;">return </span><span>*</span><span style="color:#bf616a;">this</span><span>;
</span><span>}
</span></code></pre>
<p>这段代码看起来做了很多操作，但我们只需要关注一个地方就可以了，那就是 <code>this</code> 指针。与文章开头所讲的一样，两个线程同时执行这个操作，唯一可能相同的就是变量旧值的 <code>this</code> 指针。我们顺着调用链路继续往下：</p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">template</span><span>&lt;</span><span style="color:#b48ead;">class</span><span> _Tp&gt;
</span><span style="color:#b48ead;">inline
</span><span style="color:#b48ead;">void
</span><span>shared_ptr&lt;_Tp&gt;::</span><span style="color:#8fa1b3;">swap</span><span>(shared_ptr&amp; </span><span style="color:#bf616a;">__r</span><span>) _NOEXCEPT
</span><span>{
</span><span>    _VSTD::</span><span style="color:#bf616a;">swap</span><span>(__ptr_, __r.</span><span style="color:#bf616a;">__ptr_</span><span>);
</span><span>    _VSTD::</span><span style="color:#bf616a;">swap</span><span>(__cntrl_, __r.</span><span style="color:#bf616a;">__cntrl_</span><span>);
</span><span>}
</span></code></pre>
<p>这里有两个 swap 操作，其实都是对指针的平凡交换操作，但不是原子的：</p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">template </span><span>&lt;</span><span style="color:#b48ead;">class</span><span> _Tp&gt;
</span><span style="color:#b48ead;">inline</span><span> _LIBCPP_INLINE_VISIBILITY __swap_result_t&lt;_Tp&gt; _LIBCPP_CONSTEXPR_AFTER_CXX17 </span><span style="color:#8fa1b3;">swap</span><span>(_Tp&amp; </span><span style="color:#bf616a;">__x</span><span>, _Tp&amp; </span><span style="color:#bf616a;">__y</span><span>)
</span><span>    </span><span style="color:#bf616a;">_NOEXCEPT_</span><span>(is_nothrow_move_constructible&lt;_Tp&gt;::value&amp;&amp; is_nothrow_move_assignable&lt;_Tp&gt;::value) {
</span><span>  _Tp </span><span style="color:#bf616a;">__t</span><span>(_VSTD::</span><span style="color:#bf616a;">move</span><span>(__x));
</span><span>  __x = _VSTD::</span><span style="color:#bf616a;">move</span><span>(__y);
</span><span>  __y = _VSTD::</span><span style="color:#bf616a;">move</span><span>(__t);
</span><span>}
</span></code></pre>
<p>我们考虑有两个线程同时调用到上述方法，<code>__x</code> 是新值，<code>__y</code> 是旧值，那么 <code>__x = __y</code> 这一步操作就有可能让两个线程都获取到同一个旧值。接下来，调用栈退出，在这段代码中会由于 RAII 释放两次：</p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">template</span><span>&lt;</span><span style="color:#b48ead;">class</span><span> _Tp&gt;
</span><span style="color:#b48ead;">inline
</span><span>shared_ptr&lt;_Tp&gt;&amp;
</span><span>shared_ptr&lt;_Tp&gt;::</span><span style="color:#8fa1b3;">operator=</span><span>(shared_ptr&amp;&amp; </span><span style="color:#bf616a;">__r</span><span>) _NOEXCEPT
</span><span>{
</span><span>    </span><span style="color:#bf616a;">shared_ptr</span><span>(_VSTD::</span><span style="color:#bf616a;">move</span><span>(__r)).</span><span style="color:#bf616a;">swap</span><span>(*</span><span style="color:#bf616a;">this</span><span>);
</span><span>    </span><span style="color:#b48ead;">return </span><span>*</span><span style="color:#bf616a;">this</span><span>;
</span><span>    </span><span style="color:#65737e;">// 临时变量退出作用域，其表示的旧值被释放
</span><span>}
</span></code></pre>
<p>由此我们可以得知，虽然 C++ 在这个变量交换的过程中，由于语法特性的原因，具体的操作并不与 Objective-C 相同。但根本问题还是出在对同一个对象多次释放的问题上，因为<strong>旧值获取与新值写入</strong>不是原子操作。</p>
<h3 id="ru-he-xiu-fu">如何修复</h3>
<p><strong>Attempt 1</strong></p>
<p>比较容易想到的方法就是使用 <code>std::mutex</code> 将属性赋值操作保护起来：</p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">struct </span><span>SomeObject {
</span><span>    std::mutex fieldLock;
</span><span>    std::shared_ptr&lt;std::string&gt; someProperty;
</span><span>};
</span><span>
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">writeProperty</span><span>(SomeObject *</span><span style="color:#bf616a;">obj</span><span>, std::shared_ptr&lt;std::string&gt; &amp;&amp;</span><span style="color:#bf616a;">val</span><span>) {
</span><span>    std::unique_lock&lt;std::mutex&gt; </span><span style="color:#bf616a;">lock</span><span>(obj-&gt;</span><span style="color:#bf616a;">fieldLock</span><span>);
</span><span>    obj-&gt;</span><span style="color:#bf616a;">someProperty </span><span>= std::</span><span style="color:#bf616a;">move</span><span>(val);
</span><span>}
</span></code></pre>
<p>不过这会导致一个不大不小的性能问题，如果 <code>someProperty</code> 旧值是唯一引用的，那么在赋值之后，旧值的释放就会在锁作用域中。</p>
<p><strong>Attempt 2</strong></p>
<p>如果我们先构造一个临时变量承接旧值，在锁外销毁临时变量就可以优化这个潜在的性能问题。我们这里也可以通过 swap 的方式来实现这个操作：</p>
<pre data-lang="c++" style="background-color:#2b303b;color:#c0c5ce;" class="language-c++ "><code class="language-c++" data-lang="c++"><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">writeProperty</span><span>(SomeObject *</span><span style="color:#bf616a;">obj</span><span>, std::shared_ptr&lt;std::string&gt; &amp;&amp;</span><span style="color:#bf616a;">val</span><span>) {
</span><span>    std::shared_ptr&lt;std::string&gt; </span><span style="color:#bf616a;">temp</span><span>(std::</span><span style="color:#bf616a;">move</span><span>(val));
</span><span>
</span><span>    std::unique_lock&lt;std::mutex&gt; </span><span style="color:#bf616a;">lock</span><span>(obj-&gt;</span><span style="color:#bf616a;">fieldLock</span><span>);
</span><span>    temp.</span><span style="color:#bf616a;">swap</span><span>(obj-&gt;</span><span style="color:#bf616a;">someProperty</span><span>);
</span><span>    lock.</span><span style="color:#bf616a;">unlock</span><span>();
</span><span>}
</span></code></pre>
<p>通过这种方式可以实现与 Objective-C atomic 类似的效果，首先原子地交换新值与旧值，然后在锁外释放旧值。值得注意的是，C++ 存在移动语义，第一行的临时变量其实也是与 <code>val</code> 做了一次 swap，交换之后的 <code>temp</code> 内容为 <code>val</code> 之前的内容，而 <code>val</code> 会变成一个无效对象。函数作用域退出后，<code>temp</code> 和 <code>val</code> 都会析构，但 <code>val</code> 的析构会是一个 no-op。如果开编译优化的话，<code>shared_ptr</code> 很多操作会被 inline，性能上还会更好一些。</p>
<h2 id="rust-zhong-de-qing-kuang">Rust 中的情况</h2>
<p>为了更好地回答文章标题的问题，我们这里引入 Rust 的对比，来看看相同的场景在 Rust 中是如何处理的。</p>
<p>首先我们构造相同逻辑的代码：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use </span><span>std::sync::Arc;
</span><span style="color:#b48ead;">use </span><span>std::thread;
</span><span>
</span><span style="color:#b48ead;">struct </span><span>SomeObject {
</span><span>    </span><span style="color:#bf616a;">some_field</span><span>: Arc&lt;String&gt;,
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">make_shared_string</span><span>() -&gt; Arc&lt;String&gt; {
</span><span>    Arc::new(&quot;</span><span style="color:#a3be8c;">this is a string</span><span>&quot;.</span><span style="color:#96b5b4;">to_owned</span><span>())
</span><span>}
</span><span>
</span><span>#[</span><span style="color:#bf616a;">test</span><span>]
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">test</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> obj = SomeObject {some_field: </span><span style="color:#96b5b4;">make_shared_string</span><span>()};
</span><span>    thread::scope(|</span><span style="color:#bf616a;">s</span><span>| {
</span><span>        </span><span style="color:#b48ead;">for </span><span>_ in </span><span style="color:#d08770;">0</span><span>..</span><span style="color:#d08770;">12 </span><span>{
</span><span>            s.</span><span style="color:#96b5b4;">spawn</span><span>(|| {
</span><span>                obj.some_field = </span><span style="color:#96b5b4;">make_shared_string</span><span>();
</span><span>            });
</span><span>        }
</span><span>    });
</span><span>}
</span></code></pre>
<p>编译之后我们会得到一个错误：<code>obj</code> 被多次可变引用了，这在 Rust 中是不允许的。</p>
<p>编译器如何判断闭包在结束之后仍然捕获外部变量呢？我们看到标准库中对于 Scope <code>spawn</code> 的实现：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[</span><span style="color:#bf616a;">stable</span><span>(feature = &quot;</span><span style="color:#a3be8c;">scoped_threads</span><span>&quot;, since = &quot;</span><span style="color:#a3be8c;">1.63.0</span><span>&quot;)]
</span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">spawn</span><span>&lt;F, T&gt;(&amp;</span><span style="color:#b48ead;">&#39;scope </span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">f</span><span>: F) -&gt; ScopedJoinHandle&lt;</span><span style="color:#b48ead;">&#39;scope</span><span>, T&gt;
</span><span style="color:#b48ead;">where
</span><span>    F: FnOnce() -&gt; T + Send + </span><span style="color:#b48ead;">&#39;scope</span><span>,
</span><span>    T: Send + </span><span style="color:#b48ead;">&#39;scope</span><span>,
</span><span>{
</span><span>    Builder::new().</span><span style="color:#96b5b4;">spawn_scoped</span><span>(</span><span style="color:#bf616a;">self</span><span>, f).</span><span style="color:#96b5b4;">expect</span><span>(&quot;</span><span style="color:#a3be8c;">failed to spawn thread</span><span>&quot;)
</span><span>}
</span></code></pre>
<p>可以看到，闭包 <code>F</code> 的生命周期与 Scope 本身相同，意味着里面的被捕获变量也将持续至 Scope 的销毁。单一可变引用又是 Rust 的重要原则之一，通过这种限制阻止竞态访问和一些<a href="https://stackoverflow.com/questions/58364807/why-rust-prevents-from-multiple-mutable-references">其他问题</a>。</p>
<p>既然不能存在多份可变引用，只构造多份不可变引用总可以吧。我们可以使用 &quot;Interior Mutability&quot; 来实现我们的需求吗：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">struct </span><span>SomeObject {
</span><span>    </span><span style="color:#bf616a;">some_field</span><span>: Cell&lt;Arc&lt;String&gt;&gt;,
</span><span>}
</span></code></pre>
<p>答案是不可以，因为 <code>Cell</code> 没有实现 <code>Sync</code>，因此包含 <code>Cell</code> 引用的类型将不会实现 <code>Send</code>，这些变量自然就不能跨越线程边界。很有趣的是，当我们观察 <code>Cell::set</code> 的实现可以发现：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl</span><span>&lt;T&gt; Cell&lt;T&gt; {
</span><span>    </span><span style="color:#65737e;">// ...
</span><span>
</span><span>    #[</span><span style="color:#bf616a;">inline</span><span>]
</span><span>    #[</span><span style="color:#bf616a;">stable</span><span>(feature = &quot;</span><span style="color:#a3be8c;">rust1</span><span>&quot;, since = &quot;</span><span style="color:#a3be8c;">1.0.0</span><span>&quot;)]
</span><span>    </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">set</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">val</span><span>: T) {
</span><span>        </span><span style="color:#b48ead;">let</span><span> old = </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#96b5b4;">replace</span><span>(val);
</span><span>        </span><span style="color:#96b5b4;">drop</span><span>(old);
</span><span>    }
</span><span>
</span><span>    #[</span><span style="color:#bf616a;">stable</span><span>(feature = &quot;</span><span style="color:#a3be8c;">move_cell</span><span>&quot;, since = &quot;</span><span style="color:#a3be8c;">1.17.0</span><span>&quot;)]
</span><span>    </span><span style="color:#b48ead;">pub fn </span><span style="color:#8fa1b3;">replace</span><span>(&amp;</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">val</span><span>: T) -&gt; T {
</span><span>        </span><span style="color:#65737e;">// SAFETY: This can cause data races if called from a separate thread,
</span><span>        </span><span style="color:#65737e;">// but `Cell` is `!Sync` so this won&#39;t happen.
</span><span>        mem::replace(</span><span style="color:#b48ead;">unsafe </span><span>{ &amp;</span><span style="color:#b48ead;">mut </span><span>*</span><span style="color:#bf616a;">self</span><span>.value.</span><span style="color:#96b5b4;">get</span><span>() }, val)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// ...
</span><span>}
</span></code></pre>
<p>这个实现与 C++ 里 <code>shared_ptr</code> 交换的实现一致：都是获取旧值，设置新值，销毁旧值。在没有锁保护的情况下，旧值会被释放两次。</p>
<h3 id="ru-he-xiu-fu-1">如何修复</h3>
<p>方法其实也非常简单，多线程场景直接使用 <code>Mutex</code> 就可以了，我们修改字段类型：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">struct </span><span>SomeObject {
</span><span>    </span><span style="color:#bf616a;">some_field</span><span>: Mutex&lt;Arc&lt;String&gt;&gt;,
</span><span>}
</span></code></pre>
<p>更新字段的操作也该为锁内 swap + 锁外 drop：</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#65737e;">// ...
</span><span>s.</span><span style="color:#96b5b4;">spawn</span><span>(|| </span><span style="color:#b48ead;">loop </span><span>{
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> new_value = </span><span style="color:#96b5b4;">make_shared_string</span><span>();
</span><span>    {
</span><span>        </span><span style="color:#b48ead;">let mut</span><span> some_field_guard = obj.some_field.</span><span style="color:#96b5b4;">lock</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>        std::mem::swap(&amp;</span><span style="color:#b48ead;">mut</span><span> new_value, &amp;</span><span style="color:#b48ead;">mut </span><span>*some_field_guard);
</span><span>    }
</span><span>});
</span></code></pre>
<p>Rust 对 <code>Mutex</code> 的设计非常优秀，每个 <code>Mutex</code> 都显式绑定了一个值。值要在多线程中被读写，就一定要被 <code>Mutex</code> 保护。所有实现 <code>Send</code> 的类型，都可以在套上 <code>Mutex</code> 后变成 <code>Sync</code>。而对于具有内部可变性的对象（例如 <code>Arc</code>），在多线程中使用时可以不被保护，但实际上线程安全要由对象自己负责。</p>
<blockquote>
<p><strong>为什么 <code>Mutex</code> 不能让所有的对象都变成 <code>Sync</code>？</strong></p>
<p>对于 <code>!Send</code> 类型（例如 <code>Rc</code>），他们一般会表示某些共享资源，而类型没有考虑多线程场景下的处理。例如当 <code>Rc</code> 被移动到不同的线程，很有可能出现两个线程同时 drop <code>Rc</code> 导致的引用计数不一致。</p>
</blockquote>
<p>除此之外，<code>mem::swap</code> 与单一可变借用原则也可以保证，在能够执行 swap 的上下文中，线程安全是一定会被保证的，我们无法写出不安全的 swap 操作。</p>
<p>所以通过 Rust，我们能够更好地理解文章标题所提的这个问题。拆解一下，<code>Mutex&lt;Arc&lt;T&gt;&gt;</code> 涉及了两个线程安全的保证：</p>
<ol>
<li><code>Arc</code> 自身对于引用计数的原子性修改的保证，这里采用 Atomic 操作实现；</li>
<li><code>Mutex</code> 对于 <code>Arc</code> 指针修改的保护，防止多线程操作中，由于脏值的存在，多次释放 <code>Arc</code>。</li>
</ol>
<p>也就是说，引用计数机制本身是否为线程安全，与在多线程操作同一个对象的同一个属性并无关系。</p>
<h1 id="wrap-up">Wrap Up</h1>
<p>文章看似分析了几个系统编程语言（严格说 Objective-C 不算）中的引用计数机制在多线程下的表现，但其实解释了线程安全的本质：在对象模型中，一个对象的线程安全，不意味着所有使用这个对象的场景都是线程安全的。外部对象如果不是线程安全的，即使操作了一个线程安全的对象，也有可能出现逻辑错误。本文中的引用计数只是一个例子，而恰恰这个例子涉及内存操作，很容易出现明显的 segfault。我们在日常开发中可能还会遇到其他的多线程场景，缺乏线程安全保护的逻辑问题更加不容易察觉，因此也更值得我们注意。</p>

        </div>

                </div>
            
                <div class="post on-list">
                    
    <h1 class="post-title"><a href="https://unixzii.github.io/spm-plugin-n-sandbox/">Swift Package Plugin 和 Sandbox 的那些事</a></h1>
    <div class="post-meta-inline">
        
    <span class="post-date">
            2022-07-01
        </span>

    </div>

    
        <span class="post-tags-inline">
                :: tags:&nbsp;
                <a class="post-tag" href="https://unixzii.github.io/tags/swift/">#swift</a></span>
    

                    
        <div class="post-content">
            <h1 id="qian-yan">前言</h1>
<p>Apple 今年在 WWDC 22 上推出了 <a href="https://developer.apple.com/videos/play/wwdc2022/110359"><strong>Swift Package Plugin</strong></a> 这个全新的 SPM 特性。通过 Swift Package Plugin，开发者可以扩展 Xcode 中的菜单项和构建流程，从而实现一些研发流程上的定制化、自动化。</p>
<p>我们知道，Apple 在 Xcode 8 中采用 <strong>Xcode Extensions</strong> 的全新扩展机制 deprecated 了以往没有约束的第三方插件机制。所有的 extensions 都运行在自己的独立进程中，无法随意篡改 Xcode 主程序的行为。这可以说是 Apple 的祖传艺能了，当然也极大地提升了第三方扩展的安全性。</p>
<p>而今年的 Swift Package Plugin 又给 Xcode 提供了一个不一样的扩展点，因此我也非常好奇这次的限制在哪里，开发者到底可以通过它做什么，本文会就 <strong>Command Plugin</strong> 展开讨论。</p>
<h1 id="di-yi-ge-swift-package-cha-jian">第一个 Swift Package 插件</h1>
<h2 id="gong-cheng-pei-zhi">工程配置</h2>
<p>要在现有的 package 中增加一个插件非常简单，首先创建一个 <code>Plugins</code> 目录，并再在其中创建与插件同名的目录，然后就可以编写具体的代码文件了。此时目录结构如下：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>MyAwesomePackage
</span><span>├── Package.swift
</span><span>├── Plugins
</span><span>│   └── Test
</span><span>│       └── plugin.swift
</span><span>├── README.md
</span><span>├── Sources
</span><span>│   └── MyLibrary
</span><span>│       └── MyLibrary.swift
</span><span>└── Tests
</span><span>    └── MyLibraryTests
</span><span>        └── MyLibraryTests.swif
</span></code></pre>
<p>然后修改 <code>Package.swift</code>，在 <code>targets</code> 数组中增加：</p>
<pre data-lang="swift" style="background-color:#2b303b;color:#c0c5ce;" class="language-swift "><code class="language-swift" data-lang="swift"><span style="color:#b48ead;">let</span><span> package = Package(
</span><span>    </span><span style="color:#65737e;">// ...
</span><span>    targets: [
</span><span>        .plugin(
</span><span>            name: </span><span style="color:#a3be8c;">&quot;Test&quot;</span><span>,
</span><span>            capability: .command(
</span><span>                intent: .custom(verb: </span><span style="color:#a3be8c;">&quot;test&quot;</span><span>, description: </span><span style="color:#a3be8c;">&quot;My first plugin&quot;</span><span>),
</span><span>                permissions: []))
</span><span>    ]
</span><span>)
</span></code></pre>
<p>至此就配置完毕了，等待 package 重新 resolve，之后便可在工程的右键菜单中看到我们的插件了。</p>
<h2 id="dai-ma-bian-xie">代码编写</h2>
<p>Swift Package Plugin 与普通的 CLI 程序没有太大的区别，我们需要为插件声明入口函数。这里我们要用到 <code>PackagePlugin</code> 这个 module，并实现 <code>CommandPlugin</code> 协议，它符合 <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0281-main-attribute.md">Type-Based Program Entry Points</a>。代码如下：</p>
<pre data-lang="swift" style="background-color:#2b303b;color:#c0c5ce;" class="language-swift "><code class="language-swift" data-lang="swift"><span style="color:#b48ead;">import </span><span>PackagePlugin
</span><span>
</span><span style="color:#b48ead;">@main
</span><span style="color:#b48ead;">struct</span><span> Test: CommandPlugin {
</span><span>    </span><span style="color:#b48ead;">func </span><span>performCommand(context: PluginContext, arguments: [String]) async throws {
</span><span>        </span><span style="color:#65737e;">// Do your work here...
</span><span>    }
</span><span>}
</span></code></pre>
<p>插件运行之后，<code>arguments</code> 便是 Xcode 调用我们时传入的命令行参数，在 <code>context</code> 中我们则可以拿到完整的、解析好的 package 信息，以及插件当前运行的工作目录。我们这里试着往插件工作目录中写入一个临时文件：</p>
<pre data-lang="swift" style="background-color:#2b303b;color:#c0c5ce;" class="language-swift "><code class="language-swift" data-lang="swift"><span style="color:#b48ead;">func </span><span>performCommand(context: PluginContext, arguments: [String]) async throws {
</span><span>    </span><span style="color:#b48ead;">let</span><span> temporaryFilePath = context.pluginWorkDirectory.appending(subpath: </span><span style="color:#a3be8c;">&quot;test.txt&quot;</span><span>)
</span><span>    </span><span style="color:#b48ead;">try</span><span>! </span><span style="color:#a3be8c;">&quot;hello&quot;</span><span>.write(toFile: temporaryFilePath.string, atomically: </span><span style="color:#b48ead;">true</span><span>, encoding: .utf8)
</span><span>}
</span></code></pre>
<p>运行之后便可看到 <code>test.txt</code> 已经创建。当我们修改目标路径，向桌面目录中写入一个文件时，插件运行就直接报错了：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>Test/plugin.swift:20: Fatal error: &#39;try!&#39; expression unexpectedly raised an error: Error Domain=NSCocoaErrorDomain Code=513 &quot;You don’t have permission to save the file “test.txt” in the folder “tmp”.&quot; UserInfo={NSFilePath=/var/tmp/test.txt, NSUnderlyingError=0x6000004f9d10 {Error Domain=NSPOSIXErrorDomain Code=1 &quot;Operation not permitted&quot;}}
</span></code></pre>
<p>到这里，我们其实可以初步得出结论：Swift Package Plugin 是运行在沙盒环境下的，文件读写会受控。后来我在 Activity Monitor 中也验证的确如此。</p>
<h1 id="yan-zheng-swift-package-cha-jian-de-ke-yong-quan-xian">验证 Swift Package 插件的可用权限</h1>
<h2 id="wang-luo-fang-wen">网络访问</h2>
<p>使用 <strong>Network</strong> 框架访问 <code>localhost:3000</code> 的一个本地服务：</p>
<pre data-lang="swift" style="background-color:#2b303b;color:#c0c5ce;" class="language-swift "><code class="language-swift" data-lang="swift"><span style="color:#b48ead;">func </span><span>performCommand(context: PluginContext, arguments: [String]) async throws {
</span><span>    </span><span style="color:#b48ead;">let</span><span> conn = NWConnection(to: .hostPort(host: .ipv4(.loopback), port: </span><span style="color:#d08770;">3000</span><span>), using: .tcp)
</span><span>    conn.stateUpdateHandler = {
</span><span>        print($</span><span style="color:#d08770;">0</span><span>)
</span><span>    }
</span><span>    conn.start(queue: .main)
</span><span>    </span><span style="color:#b48ead;">let</span><span> _: Void = </span><span style="color:#b48ead;">try</span><span> await withUnsafeThrowingContinuation { cont </span><span style="color:#b48ead;">in
</span><span>        conn.send(content: </span><span style="color:#a3be8c;">&quot;hello&quot;</span><span>.data(using: .utf8), completion: .contentProcessed({ error </span><span style="color:#b48ead;">in
</span><span>            </span><span style="color:#b48ead;">if let</span><span> error {
</span><span>                cont.resume(with: .failure(error))
</span><span>            } </span><span style="color:#b48ead;">else</span><span> {
</span><span>                cont.resume()
</span><span>            }
</span><span>        }))
</span><span>    }
</span><span>}
</span></code></pre>
<p>输出 <code>POSIXErrorCode: Operation not permitted</code>，因此验证无法访问网络。</p>
<h2 id="pai-sheng-zi-jin-cheng">派生子进程</h2>
<p>使用 <code>Process</code> 运行 <code>git</code> 命令：</p>
<pre data-lang="swift" style="background-color:#2b303b;color:#c0c5ce;" class="language-swift "><code class="language-swift" data-lang="swift"><span style="color:#b48ead;">func </span><span>performCommand(context: PluginContext, arguments: [String]) async throws {
</span><span>    </span><span style="color:#b48ead;">let</span><span> process = Process()
</span><span>    process.executableURL = .</span><span style="color:#b48ead;">init</span><span>(FilePath(</span><span style="color:#a3be8c;">&quot;/usr/local/bin/git&quot;</span><span>))
</span><span>    process.arguments = [</span><span style="color:#a3be8c;">&quot;--version&quot;</span><span>]
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> pipe = Pipe()
</span><span>    </span><span style="color:#b48ead;">let</span><span> stdout = pipe.fileHandleForReading
</span><span>    process.standardOutput = pipe
</span><span>
</span><span>    </span><span style="color:#b48ead;">try</span><span>! process.run()
</span><span>    process.waitUntilExit()
</span><span>    print(String(data: </span><span style="color:#b48ead;">try</span><span>! stdout.readToEnd()!, encoding: .utf8)!)
</span><span>}
</span></code></pre>
<p>输出 <code>git version 2.36.1</code>，因此验证可以派生子进程。</p>
<h2 id="xi-tong-fu-wu-fang-wen">系统服务访问</h2>
<pre data-lang="swift" style="background-color:#2b303b;color:#c0c5ce;" class="language-swift "><code class="language-swift" data-lang="swift"><span style="color:#b48ead;">func </span><span>performCommand(context: PluginContext, arguments: [String]) async throws {
</span><span>    </span><span style="color:#b48ead;">let</span><span> pboard = NSPasteboard.general
</span><span>    pboard.clearContents()
</span><span>    pboard.setString(context.pluginWorkDirectory.string, forType: .string)
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> workspace = NSWorkspace.shared
</span><span>    print(workspace.runningApplications)
</span><span>    print(workspace.</span><span style="color:#b48ead;">open</span><span>(.</span><span style="color:#b48ead;">init</span><span>(string: </span><span style="color:#a3be8c;">&quot;https://apple.com&quot;</span><span>)!))
</span><span>}
</span></code></pre>
<p>简单测试了几个基本服务，以上操作均失败。</p>
<h2 id="gui">GUI</h2>
<p>使用派生子进程的方式启动本地的计算器 app，计算器进程被 <code>SIGILL</code> 信号杀死（运行时发生 crash）。</p>
<h1 id="macos-sandbox-de-ji-zhi">macOS Sandbox 的机制</h1>
<h2 id="sandbox-exec-1">sandbox-exec(1)</h2>
<p>与 iOS 类似，macOS 也在内核层面提供了进程沙盒的支持，可以精准控制每个沙盒进程的权限（例如文件访问、Mach IPC 等系统调用）。与 iOS 不同的是，macOS 提供了一个命令行工具 <code>sandbox-exec</code>，来将沙盒的能力暴露给用户。我们可以通过 <code>sandbox-exec</code> 并配合上一个用来描述权限的 profile 文件，就可以在一个自定义的沙盒环境中执行任意进程了。</p>
<blockquote>
<p><code>sandbox-exec</code> 使用相当广泛，例如 Bazel 就通过它来实现沙盒构建，以确保构建产物的稳定性和输入输出依赖的确定性。</p>
</blockquote>
<p>当然，在用户态除了可以使用 <code>sandbox-exec</code> 以外，我们还可以使用 Sandbox API（<code>sandbox.h</code>）来执行沙盒相关的操作，<code>sandbox-exec</code> 在实现上也是基于 Sandbox API + <code>execvp</code>。</p>
<h2 id="sandbox-profile">Sandbox Profile</h2>
<p>这里我们重点看一下 <code>sandbox-exec</code> 需要的那个 profile 文件。在系统目录 <code>/System/Library/Sandbox/Profiles</code> 下可以看到很多 <code>*.sb</code> 文件，这些都是 Sandbox Profile。我们随便来看一个文件：</p>
<pre data-lang="lisp" style="background-color:#2b303b;color:#c0c5ce;" class="language-lisp "><code class="language-lisp" data-lang="lisp"><span>(version </span><span style="color:#d08770;">1</span><span>)
</span><span>
</span><span>(debug deny)
</span><span>
</span><span>(</span><span style="color:#96b5b4;">import </span><span>&quot;</span><span style="color:#a3be8c;">system.sb</span><span>&quot;)
</span><span>
</span><span style="color:#65737e;">;; allow processes to traverse symlinks
</span><span>(allow file-</span><span style="color:#96b5b4;">read</span><span>-metadata)
</span><span>
</span><span>(allow file-</span><span style="color:#96b5b4;">read</span><span>-data file-</span><span style="color:#96b5b4;">write</span><span>-data
</span><span>  (regex
</span><span>    </span><span style="color:#65737e;">; Allow files accessed by system dylibs and frameworks
</span><span>    </span><span style="color:#d08770;">#&quot;/\.CFUserTextEncoding</span><span>$&quot;
</span><span style="color:#a3be8c;">    #</span><span>&quot;^/usr/share/nls/&quot;
</span><span style="color:#a3be8c;">    #</span><span>&quot;^/usr/share/zoneinfo /var/db/timezone/zoneinfo/&quot;
</span><span style="color:#a3be8c;">  ))
</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">(allow ipc-posix-shm (ipc-posix-name </span><span>&quot;apple.shm.notification_center&quot;</span><span style="color:#a3be8c;">)) ; Libnotify
</span><span style="color:#a3be8c;">
</span><span style="color:#a3be8c;">(allow signal (target self))
</span></code></pre>
<p>Sandbox Profile 由 <a href="http://www.romab.com/ironsuite/SBPL.html">SBPL</a> 语言编写，它的语法非常类似 Lisp，也比较容易阅读。关于 Sandbox Profile 的语法和 API，可以参考这篇 <a href="https://reverse.put.as/wp-content/uploads/2011/09/Apple-Sandbox-Guide-v1.0.pdf">PDF</a>，介绍得非常完整。</p>
<p>Sandbox Profile 的核心操作就是 <code>allow</code> 和 <code>deny</code>，这是两个方法，参数均为操作和过滤器（可选）。例如 <code>(allow signal (target self))</code> 这个语句表达的意思就是：对于<strong>发送信号</strong>且信号的<strong>目标是自己</strong>的操作，<strong>允许执行</strong>。对于某些严格的运行环境，我们还可以使用 <code>(deny default)</code> 禁用掉所有操作，然后使用 <code>allow</code> 方法白名单开启需要的操作。</p>
<p>我们也可以使用通配符来对一组操作进行控制，例如 <code>(deny file-write*)</code> 这个语句会禁用以 <code>file-write</code> 为前缀的所有操作。</p>
<h2 id="jin-cheng-mo-xing">进程模型</h2>
<p>值得注意的是，Sandbox 在进程上具有继承性，即父进程会将自身的 Sandbox 状态传递给所有由它派生的子进程。这个特性也非常好理解，如果一个进程派生的子进程可以逃逸沙盒，那父进程也相当于间接逃逸沙盒了。如果这样，父进程通过管道控制沙盒外的子进程，这个机制的作用就完全失效了。</p>
<p>而 macOS 中，一个沙盒应用却可以通过 <code>open(1)</code> 或者 <code>NSWorkspace.open(_:)</code> 来以非沙盒模式启动另一个应用。这其实是系统故意留的一个“后门”，因为 Apple 理解这种情况是可控的，毕竟 Mac 作为桌面设备在权限上就会比 iPhone 这样的移动设备宽松。那这个现象是不是违背了 Sandbox 的进程模型呢，其实并没有。<code>open(1)</code> 或其他类似的启动应用方式借助的是 <strong>Launch Services</strong> 这个系统服务，它由 <code>launchd</code> 进程提供，应用通过 Mach IPC 与 <code>launchd</code> 交互，并最终由 <code>launchd</code> 启动应用，即可“逃逸沙盒”（其实在进程关系上，这个“子进程”的父进程是 <code>launchd</code>，与 Sandbox 的进程模型并不冲突）。</p>
<h1 id="swift-package-cha-jian-qi-dong-guo-cheng-fen-xi">Swift Package 插件启动过程分析</h1>
<p>我们现在知道 Swift Package Plugin 是运行在沙盒环境中，但是对其具体的 profile 尚不清楚。所以这里我会通过逆向分析 Swift Package Plugin 的启动过程，来提取其运行时的 Sandbox Profile。</p>
<p>首先需要找到一个切入点。由于 Xcode 代码日益庞大，单靠静态分析很难快速定位启动 Swift Package Plugin 的逻辑，因此这里我打算采用动态分析的方法。首先一个进程要想启动，一般会通过 <code>fork</code> + <code>exec*</code> 或者 <code>posix_spawn</code> 这几个系统调用来实现。所以这里我们先用 <code>dtrace</code> 对这几个 syscall 进行拦截（我尝试后发现是 <code>posix_spawn</code>，这里省略其他试验过程了）：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>sudo dtrace -n &#39;syscall::posix_spawn:entry/pid == 79228/ { ustack(); }&#39;
</span></code></pre>
<p>得到堆栈：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>CPU     ID                    FUNCTION:NAME
</span><span>  6    655                posix_spawn:entry
</span><span>              libsystem_kernel.dylib`__posix_spawn+0xa
</span><span>              Foundation`-[NSConcreteTask launchWithDictionary:error:]+0xe97
</span><span>              SwiftPM`specialized DefaultPluginScriptRunner.invoke(compiledExec:workingDirectory:writableDirectories:readOnlyDirectories:initialMessage:observabilityScope:callbackQueue:delegate:completion:)+0xb1f
</span><span>              SwiftPM`closure #1 in DefaultPluginScriptRunner.runPluginScript(sourceFiles:pluginName:initialMessage:toolsVersion:workingDirectory:writableDirectories:readOnlyDirectories:fileSystem:observabilityScope:callbackQueue:delegate:completion:)+0x431
</span><span>              SwiftPM`partial apply for closure #1 in DefaultPluginScriptRunner.runPluginScript(sourceFiles:pluginName:initialMessage:toolsVersion:workingDirectory:writableDirectories:readOnlyDirectories:fileSystem:observabilityScope:callbackQueue:delegate:completion:)+0x52
</span><span>              SwiftPM`partial apply for closure #4 in DefaultPluginScriptRunner.compilePluginScript(sourceFiles:pluginName:toolsVersion:observabilityScope:callbackQueue:completion:)+0x59
</span><span>              SwiftPM`thunk for @escaping @callee_guaranteed () -&gt; ()+0x19
</span><span>              libdispatch.dylib`_dispatch_call_block_and_release+0xc
</span><span>              libdispatch.dylib`_dispatch_client_callout+0x8
</span><span>              libdispatch.dylib`_dispatch_continuation_pop+0x1cc
</span><span>              libdispatch.dylib`_dispatch_async_redirect_invoke+0x2cc
</span><span>              libdispatch.dylib`_dispatch_root_queue_drain+0x157
</span><span>              libdispatch.dylib`_dispatch_worker_thread2+0xa0
</span><span>              libsystem_pthread.dylib`_pthread_wqthread+0x100
</span><span>              libsystem_pthread.dylib`start_wqthread+0xf
</span></code></pre>
<p>这里我们就得到了 Swift Package Plugin 的启动逻辑，看起来上层 API 使用的是 <code>NSTask</code>。对于提取 Sandbox Profile 的工作，我们只需拿到 <code>sandbox-exec</code> 的启动参数即可。</p>
<p>在 LLDB 中下断点：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>breakpoint set -n &quot;-[NSConcreteTask launchWithDictionary:error:]&quot;
</span></code></pre>
<p>断住后检查运行变量：</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>* thread #22, queue = &#39;swift.org.swiftpm.shared.concurrent&#39;, stop reason = breakpoint 3.1
</span><span>    frame #0: 0x00007ff81b68763c Foundation`-[NSConcreteTask launchWithDictionary:error:]
</span><span>Foundation`-[NSConcreteTask launchWithDictionary:error:]:
</span><span>-&gt;  0x7ff81b68763c &lt;+0&gt;: pushq  %rbp
</span><span>    0x7ff81b68763d &lt;+1&gt;: movq   %rsp, %rbp
</span><span>    0x7ff81b687640 &lt;+4&gt;: pushq  %r15
</span><span>    0x7ff81b687642 &lt;+6&gt;: pushq  %r14
</span><span>Target 0: (Xcode) stopped.
</span><span>
</span><span>(lldb) po $arg1
</span><span>&lt;NSConcreteTask: 0x600027b5e990&gt;
</span><span>
</span><span>(lldb) po [$arg1 arguments]
</span><span>&lt;Swift.__SwiftDeferredNSArray 0x600009f8c580&gt;(
</span><span>-p,
</span><span>(version 1)
</span><span>(deny default)
</span><span>(import &quot;system.sb&quot;)
</span><span>(allow file-read*)
</span><span>(allow process*)
</span><span>(allow file-write*
</span><span>    (subpath &quot;/private/tmp&quot;)
</span><span>    (subpath &quot;/private/var/folders/18/rdgw2vgx4g3g_1qvr7fwfhwh0000gp/T&quot;)
</span><span>)
</span><span>(deny file-write*
</span><span>    (subpath &quot;/private/var/tmp/redacted/MyLibrary&quot;)
</span><span>)
</span><span>(allow file-write*
</span><span>    (subpath &quot;/Users/redacted/Library/Developer/Xcode/DerivedData/MyLibrary-dmdwxwcobwwasxgztgazmbufnwcy/SourcePackages/plugins/Test.output&quot;)
</span><span>    (subpath &quot;/Users/redacted/Library/Developer/Xcode/DerivedData/MyLibrary-dmdwxwcobwwasxgztgazmbufnwcy/SourcePackages/plugins&quot;)
</span><span>)
</span><span>,
</span><span>/Users/redacted/Library/Developer/Xcode/DerivedData/MyLibrary-dmdwxwcobwwasxgztgazmbufnwcy/SourcePackages/plugins/Test
</span><span>)
</span></code></pre>
<p>可以看到插件的运行环境默认禁用了所有权限，而 <code>(import &quot;system.sb&quot;)</code> 只会开启几个系统进程必备的权限，其中不包括任意文件读写和任意 namespace 的 Mach IPC。后面紧接着增加了几个有限制的文件读写操作以及进程操作，方便我们在插件中对文件进行修改，或者使用子进程（如 Git 这种某些操作只有文件 I/O 的工具）。</p>
<p>上文中尝试启动计算器之所以失败，并不是因为无法派生进程，而是因为计算器进程无法创建 <code>NSWindow</code>，这个过程需要与 <code>WindowServer</code> 建立 <code>CGSConnectionID</code>，由于插件进程没有 lookup 其 namespace 的权限，因此也无法找到 Mach Port 从而进行通讯。那其他的系统服务无法使用也是同理，大部分系统服务都由名为 <code>xxxxxxd</code> 的 daemon 进程提供，clients 与服务通过 Mach Port 通讯来使用其提供的能力，系统的 frameworks 其实也只是将这些通讯封装成 High-Level APIs 提供给开发者。</p>
<h1 id="xiao-jie">小结</h1>
<p>本文简单介绍了 Swift Package Plugin 并探索了它都可以做什么。可以发现，由于沙盒环境的限制，插件可以做的事情还是非常有限的。不过这确实符合 Apple 一贯的做事风格：在一个受限可控的环境下为系统或一方应用提供扩展能力。今年 iPadOS 也很意外的获得了<a href="https://developer.apple.com/documentation/driverkit/creating_drivers_for_ipados">加载三方驱动</a>的能力，但可想而知的是，这个驱动也是基于 <code>DriverKit</code> 的受限环境，并没有与内核直接交互的能力。</p>
<p>不过相信今年看到的 Swift Package Plugin 一定不是它的终极形态，就像 SwiftUI 一样，我们可以看到它一点点变得开放和灵活。</p>

        </div>

                </div>
            <div class="pagination">
                <div class="pagination__buttons">
                    <span class="button next">
                        <a href="https://unixzii.github.io/page/2/">
                            <span class="button__text">Older posts</span>&nbsp;
                            <span class="button__icon">→</span>
                        </a>
                    </span>
                </div>
            </div>
        </div>
        

        
        <footer class="footer">
                <div class="copyright">
                        <span>© 
    2022
 Cyandev</span>
                        <span class="copyright-sep">::  </span>
                        <span>Powered by <a href="https://www.getzola.org/">Zola</a></span>
                    
                </div>
            </footer>
        
    </div>

</div>
</body>

</html>
