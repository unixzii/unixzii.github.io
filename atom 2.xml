<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>Cyandev&#x27;s Blog</title>
	<link href="https://unixzii.github.io/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://unixzii.github.io"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2022-07-27T00:00:00+00:00</updated>
	<id>https://unixzii.github.io/atom.xml</id>
	<entry xml:lang="en">
		<title>为什么 Objective-C 的属性还需要 atomic</title>
		<published>2022-07-27T00:00:00+00:00</published>
		<updated>2022-07-27T00:00:00+00:00</updated>
		<link rel="alternate" href="https://unixzii.github.io/why-objc-properties-need-atomic/" type="text/html"/>
		<id>https://unixzii.github.io/why-objc-properties-need-atomic/</id>
		<content type="html">&lt;p&gt;使用过 Objective-C 的朋友们应该都知道，将一个属性声明为 &lt;code&gt;atomic&lt;&#x2F;code&gt; 并不能解决可变对象的多线程问题。既然如此，那么这个属性存在的意义是什么呢？本文将对比多个支持引用计数的编程语言，聊聊这个古老话题的“底层逻辑”。&lt;&#x2F;p&gt;
&lt;p&gt;我们知道，&lt;code&gt;atomic&lt;&#x2F;code&gt; 和 &lt;code&gt;nonatomic&lt;&#x2F;code&gt; 主要针对对象类型的属性，对于原始类型没有影响。而对于对象类型的属性，在使用 &lt;code&gt;nonatomic&lt;&#x2F;code&gt; 的情况下，需要保证不存在多个线程同时&lt;strong&gt;读写&lt;&#x2F;strong&gt;这个属性，否则就会产生 crash。对象类型和原始类型在属性读写上有什么区别呢？答案就是引用计数。对于下面的代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;objective-c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-objective-c &quot;&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;@interface &lt;&#x2F;span&gt;&lt;span&gt;SomeObject &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;NSObject
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;@property &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;nonatomic&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;strong&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;NSObject &lt;&#x2F;span&gt;&lt;span&gt;*someProperty;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;@end
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们来看看编译器为其生成的 setter 方法（由于是生成方法，这里只会有汇编代码）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span&gt;-[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;SomeObject setSomeProperty:&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    pushq  %&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    subq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x20&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsi&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdx&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x18&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x18&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    addq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x8&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    callq  objc_storeStrong&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;  ; 关键函数
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    addq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x20&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    popq   %&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    retq
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们注意到，对于 &lt;code&gt;nonatomic&lt;&#x2F;code&gt; 属性来说，编译器生成的代码与栈上变量赋值相同，都是 &lt;code&gt;objc_storeStrong&lt;&#x2F;code&gt; 这个 runtime 函数。我们在 objc 源码中可以找到这个函数的实现：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;objective-c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-objective-c &quot;&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;objc_storeStrong&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;id &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;location&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;id &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;obj&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;id &lt;&#x2F;span&gt;&lt;span&gt;prev = *location;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(obj == prev) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;objc_retain&lt;&#x2F;span&gt;&lt;span&gt;(obj);
&lt;&#x2F;span&gt;&lt;span&gt;    *location = obj;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;objc_release&lt;&#x2F;span&gt;&lt;span&gt;(prev);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这段代码中包含了多处操作，包括内存读写和应用计数操作，多线程执行过程中的交错点也是十分多。最典型的例子就是：两个线程均读取 &lt;code&gt;location&lt;&#x2F;code&gt; 到 &lt;code&gt;prev&lt;&#x2F;code&gt;，然后分别进行后续操作，导致的结果就是同一个对象被释放多次，从而产生悬挂指针。&lt;&#x2F;p&gt;
&lt;p&gt;接下来我们来看看相同的场景，将属性换成 &lt;code&gt;atomic&lt;&#x2F;code&gt;，在生成代码上会有什么变化：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span&gt;-[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;SomeObject setSomeProperty:&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    pushq  %&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    subq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x20&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsi&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdx&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x18&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x18&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    movl   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x8&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ecx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    callq  objc_setProperty_atomic&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;  ; 关键函数
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    addq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x20&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    popq   %&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    retq
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到，关键函数变成了 &lt;code&gt;objc_setProperty_atomic&lt;&#x2F;code&gt;，这个函数的实现同样可以在源码中找到：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;objective-c&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-objective-c &quot;&gt;&lt;code class=&quot;language-objective-c&quot; data-lang=&quot;objective-c&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;objc_setProperty_atomic&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;id &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;SEL &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_cmd&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;id &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;newValue&lt;&#x2F;span&gt;&lt;span&gt;, ptrdiff_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;offset&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;reallySetProperty&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_cmd&lt;&#x2F;span&gt;&lt;span&gt;, newValue, offset, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static inline void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;reallySetProperty&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;id &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;SEL &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_cmd&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;id &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;newValue&lt;&#x2F;span&gt;&lt;span&gt;, ptrdiff_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;offset&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;atomic&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;copy&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;mutableCopy&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(offset == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;object_setClass&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, newValue);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;id &lt;&#x2F;span&gt;&lt;span&gt;oldValue;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;id &lt;&#x2F;span&gt;&lt;span&gt;*slot = (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;*) ((&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;char&lt;&#x2F;span&gt;&lt;span&gt;*)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self &lt;&#x2F;span&gt;&lt;span&gt;+ offset);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(copy) {
&lt;&#x2F;span&gt;&lt;span&gt;        newValue = [newValue &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;copyWithZone:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;nil&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else if &lt;&#x2F;span&gt;&lt;span&gt;(mutableCopy) {
&lt;&#x2F;span&gt;&lt;span&gt;        newValue = [newValue &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;mutableCopyWithZone:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;nil&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(*slot == newValue) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        newValue = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;objc_retain&lt;&#x2F;span&gt;&lt;span&gt;(newValue);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(!atomic) {
&lt;&#x2F;span&gt;&lt;span&gt;        oldValue = *slot;
&lt;&#x2F;span&gt;&lt;span&gt;        *slot = newValue;
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        spinlock_t&amp;amp; slotlock = PropertyLocks[slot];
&lt;&#x2F;span&gt;&lt;span&gt;        slotlock.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lock&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        oldValue = *slot;
&lt;&#x2F;span&gt;&lt;span&gt;        *slot = newValue;
&lt;&#x2F;span&gt;&lt;span&gt;        slotlock.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;unlock&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;objc_release&lt;&#x2F;span&gt;&lt;span&gt;(oldValue);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Runtime 在解决这个问题上也十分简单，我们只需要保证属性指针的修改和旧值的获取是一个原子操作即可。这里的原子化使用的是自旋锁，同时为了避免并发度较高的情况下，锁竞争严重，使用了一个全局的 &lt;code&gt;StripedMap&lt;&#x2F;code&gt; 来优化，这个也是很常见的优化手段了。这里其实也可以使用 CAS 操作来取代加锁操作，不过性能上是否真的有提升还需要验证。&lt;&#x2F;p&gt;
&lt;p&gt;为什么最后的 &lt;code&gt;objc_release&lt;&#x2F;code&gt; 不需要在锁的临界区呢？我们知道 &lt;code&gt;nonatomic&lt;&#x2F;code&gt; 产生问题的原因是多个线程同时获取到属性旧值并进行 release；而在 &lt;code&gt;atomic&lt;&#x2F;code&gt; 下，属性旧值获取的同时，新值就被设置了，不存在两个线程获取到同一个旧值的情况。而引用计数的增减，本身也是原子操作，所以对于所有权明确的场景下不需要额外加锁。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;qi-ta-yu-yan-zhong-de-yin-yong-ji-shu-zhi-chi&quot;&gt;其他语言中的引用计数支持&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;c-zhong-de-qing-kuang-clang-stl&quot;&gt;C++ 中的情况 (clang STL)&lt;&#x2F;h2&gt;
&lt;p&gt;既然 Objective-C 通过 &lt;code&gt;atomic&lt;&#x2F;code&gt; 属性完美解决了这个问题，C++ 中是否会存在类似的问题呢？我们也使用如下的代码来验证一下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;SomeObject {
&lt;&#x2F;span&gt;&lt;span&gt;    std::shared_ptr&amp;lt;std::string&amp;gt; someProperty;
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在多线程下同时读写 &lt;code&gt;someProperty&lt;&#x2F;code&gt; 字段也发生了 crash，这也就是说 Objective-C 中的 &lt;code&gt;nonatomic&lt;&#x2F;code&gt; 并不是一种性能优化。正如 &lt;code&gt;@synchronized&lt;&#x2F;code&gt; 一样，&lt;code&gt;atomic&lt;&#x2F;code&gt; 实际上是 Objective-C 提供给我们的额外能力，方便处理这种多线程场景。&lt;&#x2F;p&gt;
&lt;p&gt;在 C++ 中的 crash 原因与 Objective-C 中的 &lt;code&gt;nonatomic&lt;&#x2F;code&gt; 非常相似，我们也来看一下对 &lt;code&gt;someProperty&lt;&#x2F;code&gt; 赋值的过程发生了什么。我这里写了一个赋值函数：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;writeProperty&lt;&#x2F;span&gt;&lt;span&gt;(SomeObject *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;obj&lt;&#x2F;span&gt;&lt;span&gt;, std::shared_ptr&amp;lt;std::string&amp;gt; &amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;val&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    obj-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;someProperty &lt;&#x2F;span&gt;&lt;span&gt;= std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;move&lt;&#x2F;span&gt;&lt;span&gt;(val);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其汇编如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;writeProperty:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    pushq  %&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    subq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x10&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsi&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x10&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    callq  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;std&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;::__1::move&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;std&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;::__1::shared_ptr&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;std&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;::__1::basic_string&amp;lt;char&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;std&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;::__1::char_traits&amp;lt;char&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;&amp;lt;char&amp;gt; &amp;gt; &amp;gt;&amp;amp;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;at &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;move.h:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;27
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;movq   &lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;(%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;)&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    ; 关键方法:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    callq  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;std&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;::__1::shared_ptr&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;std&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;::__1::basic_string&amp;lt;char&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;std&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;::__1::char_traits&amp;lt;char&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;std&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;::__1::allocator&amp;lt;char&amp;gt; &amp;gt; red_ptr.h:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;989
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    addq   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;$&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x10&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    popq   %&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    retq
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;由于 C++ 支持 &lt;code&gt;operator=&lt;&#x2F;code&gt; 来自定义对象赋值操作，因此简单的赋值表达式其实也是一个函数调用，这里展示的是 inline 之后的结果。而 &lt;code&gt;std::move&lt;&#x2F;code&gt; 是一个 cast 操作，对值内容其实没有任何影响，我们可以直接分析其中的关键方法。这个方法的符号在编译时被模板展开了，实际上对应的是 &lt;code&gt;std::shared_ptr&lt;&#x2F;code&gt; 如下方法：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class&lt;&#x2F;span&gt;&lt;span&gt; _Tp&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;inline
&lt;&#x2F;span&gt;&lt;span&gt;shared_ptr&amp;lt;_Tp&amp;gt;&amp;amp;
&lt;&#x2F;span&gt;&lt;span&gt;shared_ptr&amp;lt;_Tp&amp;gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;operator=&lt;&#x2F;span&gt;&lt;span&gt;(shared_ptr&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__r&lt;&#x2F;span&gt;&lt;span&gt;) _NOEXCEPT
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;shared_ptr&lt;&#x2F;span&gt;&lt;span&gt;(_VSTD::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;move&lt;&#x2F;span&gt;&lt;span&gt;(__r)).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;swap&lt;&#x2F;span&gt;&lt;span&gt;(*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这段代码看起来做了很多操作，但我们只需要关注一个地方就可以了，那就是 &lt;code&gt;this&lt;&#x2F;code&gt; 指针。与文章开头所讲的一样，两个线程同时执行这个操作，唯一可能相同的就是变量旧值的 &lt;code&gt;this&lt;&#x2F;code&gt; 指针。我们顺着调用链路继续往下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class&lt;&#x2F;span&gt;&lt;span&gt; _Tp&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;inline
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void
&lt;&#x2F;span&gt;&lt;span&gt;shared_ptr&amp;lt;_Tp&amp;gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;swap&lt;&#x2F;span&gt;&lt;span&gt;(shared_ptr&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__r&lt;&#x2F;span&gt;&lt;span&gt;) _NOEXCEPT
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    _VSTD::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;swap&lt;&#x2F;span&gt;&lt;span&gt;(__ptr_, __r.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__ptr_&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    _VSTD::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;swap&lt;&#x2F;span&gt;&lt;span&gt;(__cntrl_, __r.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__cntrl_&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里有两个 swap 操作，其实都是对指针的平凡交换操作，但不是原子的：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class&lt;&#x2F;span&gt;&lt;span&gt; _Tp&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;inline&lt;&#x2F;span&gt;&lt;span&gt; _LIBCPP_INLINE_VISIBILITY __swap_result_t&amp;lt;_Tp&amp;gt; _LIBCPP_CONSTEXPR_AFTER_CXX17 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;swap&lt;&#x2F;span&gt;&lt;span&gt;(_Tp&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__x&lt;&#x2F;span&gt;&lt;span&gt;, _Tp&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__y&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_NOEXCEPT_&lt;&#x2F;span&gt;&lt;span&gt;(is_nothrow_move_constructible&amp;lt;_Tp&amp;gt;::value&amp;amp;&amp;amp; is_nothrow_move_assignable&amp;lt;_Tp&amp;gt;::value) {
&lt;&#x2F;span&gt;&lt;span&gt;  _Tp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__t&lt;&#x2F;span&gt;&lt;span&gt;(_VSTD::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;move&lt;&#x2F;span&gt;&lt;span&gt;(__x));
&lt;&#x2F;span&gt;&lt;span&gt;  __x = _VSTD::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;move&lt;&#x2F;span&gt;&lt;span&gt;(__y);
&lt;&#x2F;span&gt;&lt;span&gt;  __y = _VSTD::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;move&lt;&#x2F;span&gt;&lt;span&gt;(__t);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们考虑有两个线程同时调用到上述方法，&lt;code&gt;__x&lt;&#x2F;code&gt; 是新值，&lt;code&gt;__y&lt;&#x2F;code&gt; 是旧值，那么 &lt;code&gt;__x = __y&lt;&#x2F;code&gt; 这一步操作就有可能让两个线程都获取到同一个旧值。接下来，调用栈退出，在这段代码中会由于 RAII 释放两次：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class&lt;&#x2F;span&gt;&lt;span&gt; _Tp&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;inline
&lt;&#x2F;span&gt;&lt;span&gt;shared_ptr&amp;lt;_Tp&amp;gt;&amp;amp;
&lt;&#x2F;span&gt;&lt;span&gt;shared_ptr&amp;lt;_Tp&amp;gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;operator=&lt;&#x2F;span&gt;&lt;span&gt;(shared_ptr&amp;amp;&amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;__r&lt;&#x2F;span&gt;&lt;span&gt;) _NOEXCEPT
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;shared_ptr&lt;&#x2F;span&gt;&lt;span&gt;(_VSTD::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;move&lt;&#x2F;span&gt;&lt;span&gt;(__r)).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;swap&lt;&#x2F;span&gt;&lt;span&gt;(*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 临时变量退出作用域，其表示的旧值被释放
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;由此我们可以得知，虽然 C++ 在这个变量交换的过程中，由于语法特性的原因，具体的操作并不与 Objective-C 相同。但根本问题还是出在对同一个对象多次释放的问题上，因为&lt;strong&gt;旧值获取与新值写入&lt;&#x2F;strong&gt;不是原子操作。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ru-he-xiu-fu&quot;&gt;如何修复&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;Attempt 1&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;比较容易想到的方法就是使用 &lt;code&gt;std::mutex&lt;&#x2F;code&gt; 将属性赋值操作保护起来：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;SomeObject {
&lt;&#x2F;span&gt;&lt;span&gt;    std::mutex fieldLock;
&lt;&#x2F;span&gt;&lt;span&gt;    std::shared_ptr&amp;lt;std::string&amp;gt; someProperty;
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;writeProperty&lt;&#x2F;span&gt;&lt;span&gt;(SomeObject *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;obj&lt;&#x2F;span&gt;&lt;span&gt;, std::shared_ptr&amp;lt;std::string&amp;gt; &amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;val&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    std::unique_lock&amp;lt;std::mutex&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lock&lt;&#x2F;span&gt;&lt;span&gt;(obj-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fieldLock&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    obj-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;someProperty &lt;&#x2F;span&gt;&lt;span&gt;= std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;move&lt;&#x2F;span&gt;&lt;span&gt;(val);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;不过这会导致一个不大不小的性能问题，如果 &lt;code&gt;someProperty&lt;&#x2F;code&gt; 旧值是唯一引用的，那么在赋值之后，旧值的释放就会在锁作用域中。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Attempt 2&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;如果我们先构造一个临时变量承接旧值，在锁外销毁临时变量就可以优化这个潜在的性能问题。我们这里也可以通过 swap 的方式来实现这个操作：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;writeProperty&lt;&#x2F;span&gt;&lt;span&gt;(SomeObject *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;obj&lt;&#x2F;span&gt;&lt;span&gt;, std::shared_ptr&amp;lt;std::string&amp;gt; &amp;amp;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;val&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    std::shared_ptr&amp;lt;std::string&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;temp&lt;&#x2F;span&gt;&lt;span&gt;(std::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;move&lt;&#x2F;span&gt;&lt;span&gt;(val));
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    std::unique_lock&amp;lt;std::mutex&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;lock&lt;&#x2F;span&gt;&lt;span&gt;(obj-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;fieldLock&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    temp.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;swap&lt;&#x2F;span&gt;&lt;span&gt;(obj-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;someProperty&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    lock.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;unlock&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;通过这种方式可以实现与 Objective-C atomic 类似的效果，首先原子地交换新值与旧值，然后在锁外释放旧值。值得注意的是，C++ 存在移动语义，第一行的临时变量其实也是与 &lt;code&gt;val&lt;&#x2F;code&gt; 做了一次 swap，交换之后的 &lt;code&gt;temp&lt;&#x2F;code&gt; 内容为 &lt;code&gt;val&lt;&#x2F;code&gt; 之前的内容，而 &lt;code&gt;val&lt;&#x2F;code&gt; 会变成一个无效对象。函数作用域退出后，&lt;code&gt;temp&lt;&#x2F;code&gt; 和 &lt;code&gt;val&lt;&#x2F;code&gt; 都会析构，但 &lt;code&gt;val&lt;&#x2F;code&gt; 的析构会是一个 no-op。如果开编译优化的话，&lt;code&gt;shared_ptr&lt;&#x2F;code&gt; 很多操作会被 inline，性能上还会更好一些。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rust-zhong-de-qing-kuang&quot;&gt;Rust 中的情况&lt;&#x2F;h2&gt;
&lt;p&gt;为了更好地回答文章标题的问题，我们这里引入 Rust 的对比，来看看相同的场景在 Rust 中是如何处理的。&lt;&#x2F;p&gt;
&lt;p&gt;首先我们构造相同逻辑的代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;std::sync::Arc;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;std::thread;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;SomeObject {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;some_field&lt;&#x2F;span&gt;&lt;span&gt;: Arc&amp;lt;String&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;make_shared_string&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; Arc&amp;lt;String&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    Arc::new(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;this is a string&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;to_owned&lt;&#x2F;span&gt;&lt;span&gt;())
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; obj = SomeObject {some_field: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;make_shared_string&lt;&#x2F;span&gt;&lt;span&gt;()};
&lt;&#x2F;span&gt;&lt;span&gt;    thread::scope(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;s&lt;&#x2F;span&gt;&lt;span&gt;| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;_ in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            s.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;spawn&lt;&#x2F;span&gt;&lt;span&gt;(|| {
&lt;&#x2F;span&gt;&lt;span&gt;                obj.some_field = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;make_shared_string&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;            });
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;编译之后我们会得到一个错误：&lt;code&gt;obj&lt;&#x2F;code&gt; 被多次可变引用了，这在 Rust 中是不允许的。&lt;&#x2F;p&gt;
&lt;p&gt;编译器如何判断闭包在结束之后仍然捕获外部变量呢？我们看到标准库中对于 Scope &lt;code&gt;spawn&lt;&#x2F;code&gt; 的实现：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;stable&lt;&#x2F;span&gt;&lt;span&gt;(feature = &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;scoped_threads&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, since = &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;1.63.0&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;spawn&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F, T&amp;gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;scope &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: F) -&amp;gt; ScopedJoinHandle&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;scope&lt;&#x2F;span&gt;&lt;span&gt;, T&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;    F: FnOnce() -&amp;gt; T + Send + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;scope&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    T: Send + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;&amp;#39;scope&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    Builder::new().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;spawn_scoped&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, f).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;expect&lt;&#x2F;span&gt;&lt;span&gt;(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;failed to spawn thread&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到，闭包 &lt;code&gt;F&lt;&#x2F;code&gt; 的生命周期与 Scope 本身相同，意味着里面的被捕获变量也将持续至 Scope 的销毁。单一可变引用又是 Rust 的重要原则之一，通过这种限制阻止竞态访问和一些&lt;a href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;58364807&#x2F;why-rust-prevents-from-multiple-mutable-references&quot;&gt;其他问题&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;既然不能存在多份可变引用，只构造多份不可变引用总可以吧。我们可以使用 &amp;quot;Interior Mutability&amp;quot; 来实现我们的需求吗：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;SomeObject {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;some_field&lt;&#x2F;span&gt;&lt;span&gt;: Cell&amp;lt;Arc&amp;lt;String&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;答案是不可以，因为 &lt;code&gt;Cell&lt;&#x2F;code&gt; 没有实现 &lt;code&gt;Sync&lt;&#x2F;code&gt;，因此包含 &lt;code&gt;Cell&lt;&#x2F;code&gt; 引用的类型将不会实现 &lt;code&gt;Send&lt;&#x2F;code&gt;，这些变量自然就不能跨越线程边界。很有趣的是，当我们观察 &lt;code&gt;Cell::set&lt;&#x2F;code&gt; 的实现可以发现：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; Cell&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    #[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;inline&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;    #[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;stable&lt;&#x2F;span&gt;&lt;span&gt;(feature = &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;rust1&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, since = &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;1.0.0&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;set&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;val&lt;&#x2F;span&gt;&lt;span&gt;: T) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; old = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;replace&lt;&#x2F;span&gt;&lt;span&gt;(val);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;drop&lt;&#x2F;span&gt;&lt;span&gt;(old);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    #[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;stable&lt;&#x2F;span&gt;&lt;span&gt;(feature = &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;move_cell&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;, since = &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;1.17.0&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)]
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;replace&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;val&lt;&#x2F;span&gt;&lt;span&gt;: T) -&amp;gt; T {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; SAFETY: This can cause data races if called from a separate thread,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; but `Cell` is `!Sync` so this won&amp;#39;t happen.
&lt;&#x2F;span&gt;&lt;span&gt;        mem::replace(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{ &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.value.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;get&lt;&#x2F;span&gt;&lt;span&gt;() }, val)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个实现与 C++ 里 &lt;code&gt;shared_ptr&lt;&#x2F;code&gt; 交换的实现一致：都是获取旧值，设置新值，销毁旧值。在没有锁保护的情况下，旧值会被释放两次。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ru-he-xiu-fu-1&quot;&gt;如何修复&lt;&#x2F;h3&gt;
&lt;p&gt;方法其实也非常简单，多线程场景直接使用 &lt;code&gt;Mutex&lt;&#x2F;code&gt; 就可以了，我们修改字段类型：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;SomeObject {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;some_field&lt;&#x2F;span&gt;&lt;span&gt;: Mutex&amp;lt;Arc&amp;lt;String&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;更新字段的操作也该为锁内 swap + 锁外 drop：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;s.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;spawn&lt;&#x2F;span&gt;&lt;span&gt;(|| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; new_value = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;make_shared_string&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; some_field_guard = obj.some_field.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;lock&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        std::mem::swap(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span&gt; new_value, &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span&gt;*some_field_guard);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;});
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Rust 对 &lt;code&gt;Mutex&lt;&#x2F;code&gt; 的设计非常优秀，每个 &lt;code&gt;Mutex&lt;&#x2F;code&gt; 都显式绑定了一个值。值要在多线程中被读写，就一定要被 &lt;code&gt;Mutex&lt;&#x2F;code&gt; 保护。所有实现 &lt;code&gt;Send&lt;&#x2F;code&gt; 的类型，都可以在套上 &lt;code&gt;Mutex&lt;&#x2F;code&gt; 后变成 &lt;code&gt;Sync&lt;&#x2F;code&gt;。而对于具有内部可变性的对象（例如 &lt;code&gt;Arc&lt;&#x2F;code&gt;），在多线程中使用时可以不被保护，但实际上线程安全要由对象自己负责。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么 &lt;code&gt;Mutex&lt;&#x2F;code&gt; 不能让所有的对象都变成 &lt;code&gt;Sync&lt;&#x2F;code&gt;？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;对于 &lt;code&gt;!Send&lt;&#x2F;code&gt; 类型（例如 &lt;code&gt;Rc&lt;&#x2F;code&gt;），他们一般会表示某些共享资源，而类型没有考虑多线程场景下的处理。例如当 &lt;code&gt;Rc&lt;&#x2F;code&gt; 被移动到不同的线程，很有可能出现两个线程同时 drop &lt;code&gt;Rc&lt;&#x2F;code&gt; 导致的引用计数不一致。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;除此之外，&lt;code&gt;mem::swap&lt;&#x2F;code&gt; 与单一可变借用原则也可以保证，在能够执行 swap 的上下文中，线程安全是一定会被保证的，我们无法写出不安全的 swap 操作。&lt;&#x2F;p&gt;
&lt;p&gt;所以通过 Rust，我们能够更好地理解文章标题所提的这个问题。拆解一下，&lt;code&gt;Mutex&amp;lt;Arc&amp;lt;T&amp;gt;&amp;gt;&lt;&#x2F;code&gt; 涉及了两个线程安全的保证：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Arc&lt;&#x2F;code&gt; 自身对于引用计数的原子性修改的保证，这里采用 Atomic 操作实现；&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Mutex&lt;&#x2F;code&gt; 对于 &lt;code&gt;Arc&lt;&#x2F;code&gt; 指针修改的保护，防止多线程操作中，由于脏值的存在，多次释放 &lt;code&gt;Arc&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;也就是说，引用计数机制本身是否为线程安全，与在多线程操作同一个对象的同一个属性并无关系。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;wrap-up&quot;&gt;Wrap Up&lt;&#x2F;h1&gt;
&lt;p&gt;文章看似分析了几个系统编程语言（严格说 Objective-C 不算）中的引用计数机制在多线程下的表现，但其实解释了线程安全的本质：在对象模型中，一个对象的线程安全，不意味着所有使用这个对象的场景都是线程安全的。外部对象如果不是线程安全的，即使操作了一个线程安全的对象，也有可能出现逻辑错误。本文中的引用计数只是一个例子，而恰恰这个例子涉及内存操作，很容易出现明显的 segfault。我们在日常开发中可能还会遇到其他的多线程场景，缺乏线程安全保护的逻辑问题更加不容易察觉，因此也更值得我们注意。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Swift Package Plugin 和 Sandbox 的那些事</title>
		<published>2022-07-01T00:00:00+00:00</published>
		<updated>2022-07-01T00:00:00+00:00</updated>
		<link rel="alternate" href="https://unixzii.github.io/spm-plugin-n-sandbox/" type="text/html"/>
		<id>https://unixzii.github.io/spm-plugin-n-sandbox/</id>
		<content type="html">&lt;h1 id=&quot;qian-yan&quot;&gt;前言&lt;&#x2F;h1&gt;
&lt;p&gt;Apple 今年在 WWDC 22 上推出了 &lt;a href=&quot;https:&#x2F;&#x2F;developer.apple.com&#x2F;videos&#x2F;play&#x2F;wwdc2022&#x2F;110359&quot;&gt;&lt;strong&gt;Swift Package Plugin&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; 这个全新的 SPM 特性。通过 Swift Package Plugin，开发者可以扩展 Xcode 中的菜单项和构建流程，从而实现一些研发流程上的定制化、自动化。&lt;&#x2F;p&gt;
&lt;p&gt;我们知道，Apple 在 Xcode 8 中采用 &lt;strong&gt;Xcode Extensions&lt;&#x2F;strong&gt; 的全新扩展机制 deprecated 了以往没有约束的第三方插件机制。所有的 extensions 都运行在自己的独立进程中，无法随意篡改 Xcode 主程序的行为。这可以说是 Apple 的祖传艺能了，当然也极大地提升了第三方扩展的安全性。&lt;&#x2F;p&gt;
&lt;p&gt;而今年的 Swift Package Plugin 又给 Xcode 提供了一个不一样的扩展点，因此我也非常好奇这次的限制在哪里，开发者到底可以通过它做什么，本文会就 &lt;strong&gt;Command Plugin&lt;&#x2F;strong&gt; 展开讨论。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;di-yi-ge-swift-package-cha-jian&quot;&gt;第一个 Swift Package 插件&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;gong-cheng-pei-zhi&quot;&gt;工程配置&lt;&#x2F;h2&gt;
&lt;p&gt;要在现有的 package 中增加一个插件非常简单，首先创建一个 &lt;code&gt;Plugins&lt;&#x2F;code&gt; 目录，并再在其中创建与插件同名的目录，然后就可以编写具体的代码文件了。此时目录结构如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;MyAwesomePackage
&lt;&#x2F;span&gt;&lt;span&gt;├── Package.swift
&lt;&#x2F;span&gt;&lt;span&gt;├── Plugins
&lt;&#x2F;span&gt;&lt;span&gt;│   └── Test
&lt;&#x2F;span&gt;&lt;span&gt;│       └── plugin.swift
&lt;&#x2F;span&gt;&lt;span&gt;├── README.md
&lt;&#x2F;span&gt;&lt;span&gt;├── Sources
&lt;&#x2F;span&gt;&lt;span&gt;│   └── MyLibrary
&lt;&#x2F;span&gt;&lt;span&gt;│       └── MyLibrary.swift
&lt;&#x2F;span&gt;&lt;span&gt;└── Tests
&lt;&#x2F;span&gt;&lt;span&gt;    └── MyLibraryTests
&lt;&#x2F;span&gt;&lt;span&gt;        └── MyLibraryTests.swif
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后修改 &lt;code&gt;Package.swift&lt;&#x2F;code&gt;，在 &lt;code&gt;targets&lt;&#x2F;code&gt; 数组中增加：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;swift&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-swift &quot;&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; package = Package(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    targets: [
&lt;&#x2F;span&gt;&lt;span&gt;        .plugin(
&lt;&#x2F;span&gt;&lt;span&gt;            name: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;Test&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;            capability: .command(
&lt;&#x2F;span&gt;&lt;span&gt;                intent: .custom(verb: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;test&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, description: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;My first plugin&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;                permissions: []))
&lt;&#x2F;span&gt;&lt;span&gt;    ]
&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;至此就配置完毕了，等待 package 重新 resolve，之后便可在工程的右键菜单中看到我们的插件了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dai-ma-bian-xie&quot;&gt;代码编写&lt;&#x2F;h2&gt;
&lt;p&gt;Swift Package Plugin 与普通的 CLI 程序没有太大的区别，我们需要为插件声明入口函数。这里我们要用到 &lt;code&gt;PackagePlugin&lt;&#x2F;code&gt; 这个 module，并实现 &lt;code&gt;CommandPlugin&lt;&#x2F;code&gt; 协议，它符合 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;swift-evolution&#x2F;blob&#x2F;main&#x2F;proposals&#x2F;0281-main-attribute.md&quot;&gt;Type-Based Program Entry Points&lt;&#x2F;a&gt;。代码如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;swift&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-swift &quot;&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;import &lt;&#x2F;span&gt;&lt;span&gt;PackagePlugin
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;@main
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span&gt; Test: CommandPlugin {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;func &lt;&#x2F;span&gt;&lt;span&gt;performCommand(context: PluginContext, arguments: [String]) async throws {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Do your work here...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;插件运行之后，&lt;code&gt;arguments&lt;&#x2F;code&gt; 便是 Xcode 调用我们时传入的命令行参数，在 &lt;code&gt;context&lt;&#x2F;code&gt; 中我们则可以拿到完整的、解析好的 package 信息，以及插件当前运行的工作目录。我们这里试着往插件工作目录中写入一个临时文件：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;swift&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-swift &quot;&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;func &lt;&#x2F;span&gt;&lt;span&gt;performCommand(context: PluginContext, arguments: [String]) async throws {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; temporaryFilePath = context.pluginWorkDirectory.appending(subpath: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;test.txt&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;try&lt;&#x2F;span&gt;&lt;span&gt;! &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;hello&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.write(toFile: temporaryFilePath.string, atomically: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;, encoding: .utf8)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;运行之后便可看到 &lt;code&gt;test.txt&lt;&#x2F;code&gt; 已经创建。当我们修改目标路径，向桌面目录中写入一个文件时，插件运行就直接报错了：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Test&#x2F;plugin.swift:20: Fatal error: &amp;#39;try!&amp;#39; expression unexpectedly raised an error: Error Domain=NSCocoaErrorDomain Code=513 &amp;quot;You don’t have permission to save the file “test.txt” in the folder “tmp”.&amp;quot; UserInfo={NSFilePath=&#x2F;var&#x2F;tmp&#x2F;test.txt, NSUnderlyingError=0x6000004f9d10 {Error Domain=NSPOSIXErrorDomain Code=1 &amp;quot;Operation not permitted&amp;quot;}}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;到这里，我们其实可以初步得出结论：Swift Package Plugin 是运行在沙盒环境下的，文件读写会受控。后来我在 Activity Monitor 中也验证的确如此。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;yan-zheng-swift-package-cha-jian-de-ke-yong-quan-xian&quot;&gt;验证 Swift Package 插件的可用权限&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;wang-luo-fang-wen&quot;&gt;网络访问&lt;&#x2F;h2&gt;
&lt;p&gt;使用 &lt;strong&gt;Network&lt;&#x2F;strong&gt; 框架访问 &lt;code&gt;localhost:3000&lt;&#x2F;code&gt; 的一个本地服务：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;swift&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-swift &quot;&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;func &lt;&#x2F;span&gt;&lt;span&gt;performCommand(context: PluginContext, arguments: [String]) async throws {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; conn = NWConnection(to: .hostPort(host: .ipv4(.loopback), port: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;3000&lt;&#x2F;span&gt;&lt;span&gt;), using: .tcp)
&lt;&#x2F;span&gt;&lt;span&gt;    conn.stateUpdateHandler = {
&lt;&#x2F;span&gt;&lt;span&gt;        print($&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    conn.start(queue: .main)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; _: Void = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;try&lt;&#x2F;span&gt;&lt;span&gt; await withUnsafeThrowingContinuation { cont &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;in
&lt;&#x2F;span&gt;&lt;span&gt;        conn.send(content: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;hello&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.data(using: .utf8), completion: .contentProcessed({ error &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;in
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if let&lt;&#x2F;span&gt;&lt;span&gt; error {
&lt;&#x2F;span&gt;&lt;span&gt;                cont.resume(with: .failure(error))
&lt;&#x2F;span&gt;&lt;span&gt;            } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else&lt;&#x2F;span&gt;&lt;span&gt; {
&lt;&#x2F;span&gt;&lt;span&gt;                cont.resume()
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }))
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出 &lt;code&gt;POSIXErrorCode: Operation not permitted&lt;&#x2F;code&gt;，因此验证无法访问网络。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;pai-sheng-zi-jin-cheng&quot;&gt;派生子进程&lt;&#x2F;h2&gt;
&lt;p&gt;使用 &lt;code&gt;Process&lt;&#x2F;code&gt; 运行 &lt;code&gt;git&lt;&#x2F;code&gt; 命令：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;swift&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-swift &quot;&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;func &lt;&#x2F;span&gt;&lt;span&gt;performCommand(context: PluginContext, arguments: [String]) async throws {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; process = Process()
&lt;&#x2F;span&gt;&lt;span&gt;    process.executableURL = .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;init&lt;&#x2F;span&gt;&lt;span&gt;(FilePath(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;git&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;    process.arguments = [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;--version&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; pipe = Pipe()
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; stdout = pipe.fileHandleForReading
&lt;&#x2F;span&gt;&lt;span&gt;    process.standardOutput = pipe
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;try&lt;&#x2F;span&gt;&lt;span&gt;! process.run()
&lt;&#x2F;span&gt;&lt;span&gt;    process.waitUntilExit()
&lt;&#x2F;span&gt;&lt;span&gt;    print(String(data: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;try&lt;&#x2F;span&gt;&lt;span&gt;! stdout.readToEnd()!, encoding: .utf8)!)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;输出 &lt;code&gt;git version 2.36.1&lt;&#x2F;code&gt;，因此验证可以派生子进程。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;xi-tong-fu-wu-fang-wen&quot;&gt;系统服务访问&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;swift&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-swift &quot;&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;func &lt;&#x2F;span&gt;&lt;span&gt;performCommand(context: PluginContext, arguments: [String]) async throws {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; pboard = NSPasteboard.general
&lt;&#x2F;span&gt;&lt;span&gt;    pboard.clearContents()
&lt;&#x2F;span&gt;&lt;span&gt;    pboard.setString(context.pluginWorkDirectory.string, forType: .string)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; workspace = NSWorkspace.shared
&lt;&#x2F;span&gt;&lt;span&gt;    print(workspace.runningApplications)
&lt;&#x2F;span&gt;&lt;span&gt;    print(workspace.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;open&lt;&#x2F;span&gt;&lt;span&gt;(.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;init&lt;&#x2F;span&gt;&lt;span&gt;(string: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;https:&#x2F;&#x2F;apple.com&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)!))
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;简单测试了几个基本服务，以上操作均失败。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gui&quot;&gt;GUI&lt;&#x2F;h2&gt;
&lt;p&gt;使用派生子进程的方式启动本地的计算器 app，计算器进程被 &lt;code&gt;SIGILL&lt;&#x2F;code&gt; 信号杀死（运行时发生 crash）。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;macos-sandbox-de-ji-zhi&quot;&gt;macOS Sandbox 的机制&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;sandbox-exec-1&quot;&gt;sandbox-exec(1)&lt;&#x2F;h2&gt;
&lt;p&gt;与 iOS 类似，macOS 也在内核层面提供了进程沙盒的支持，可以精准控制每个沙盒进程的权限（例如文件访问、Mach IPC 等系统调用）。与 iOS 不同的是，macOS 提供了一个命令行工具 &lt;code&gt;sandbox-exec&lt;&#x2F;code&gt;，来将沙盒的能力暴露给用户。我们可以通过 &lt;code&gt;sandbox-exec&lt;&#x2F;code&gt; 并配合上一个用来描述权限的 profile 文件，就可以在一个自定义的沙盒环境中执行任意进程了。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;sandbox-exec&lt;&#x2F;code&gt; 使用相当广泛，例如 Bazel 就通过它来实现沙盒构建，以确保构建产物的稳定性和输入输出依赖的确定性。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;当然，在用户态除了可以使用 &lt;code&gt;sandbox-exec&lt;&#x2F;code&gt; 以外，我们还可以使用 Sandbox API（&lt;code&gt;sandbox.h&lt;&#x2F;code&gt;）来执行沙盒相关的操作，&lt;code&gt;sandbox-exec&lt;&#x2F;code&gt; 在实现上也是基于 Sandbox API + &lt;code&gt;execvp&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;sandbox-profile&quot;&gt;Sandbox Profile&lt;&#x2F;h2&gt;
&lt;p&gt;这里我们重点看一下 &lt;code&gt;sandbox-exec&lt;&#x2F;code&gt; 需要的那个 profile 文件。在系统目录 &lt;code&gt;&#x2F;System&#x2F;Library&#x2F;Sandbox&#x2F;Profiles&lt;&#x2F;code&gt; 下可以看到很多 &lt;code&gt;*.sb&lt;&#x2F;code&gt; 文件，这些都是 Sandbox Profile。我们随便来看一个文件：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;lisp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-lisp &quot;&gt;&lt;code class=&quot;language-lisp&quot; data-lang=&quot;lisp&quot;&gt;&lt;span&gt;(version &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(debug deny)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;import &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;system.sb&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;;; allow processes to traverse symlinks
&lt;&#x2F;span&gt;&lt;span&gt;(allow file-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;read&lt;&#x2F;span&gt;&lt;span&gt;-metadata)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(allow file-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;read&lt;&#x2F;span&gt;&lt;span&gt;-data file-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span&gt;-data
&lt;&#x2F;span&gt;&lt;span&gt;  (regex
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;; Allow files accessed by system dylibs and frameworks
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;#&amp;quot;&#x2F;\.CFUserTextEncoding&lt;&#x2F;span&gt;&lt;span&gt;$&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;    #&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;^&#x2F;usr&#x2F;share&#x2F;nls&#x2F;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;    #&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;^&#x2F;usr&#x2F;share&#x2F;zoneinfo &#x2F;var&#x2F;db&#x2F;timezone&#x2F;zoneinfo&#x2F;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;  ))
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;(allow ipc-posix-shm (ipc-posix-name &lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;apple.shm.notification_center&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;)) ; Libnotify
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;(allow signal (target self))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Sandbox Profile 由 &lt;a href=&quot;http:&#x2F;&#x2F;www.romab.com&#x2F;ironsuite&#x2F;SBPL.html&quot;&gt;SBPL&lt;&#x2F;a&gt; 语言编写，它的语法非常类似 Lisp，也比较容易阅读。关于 Sandbox Profile 的语法和 API，可以参考这篇 &lt;a href=&quot;https:&#x2F;&#x2F;reverse.put.as&#x2F;wp-content&#x2F;uploads&#x2F;2011&#x2F;09&#x2F;Apple-Sandbox-Guide-v1.0.pdf&quot;&gt;PDF&lt;&#x2F;a&gt;，介绍得非常完整。&lt;&#x2F;p&gt;
&lt;p&gt;Sandbox Profile 的核心操作就是 &lt;code&gt;allow&lt;&#x2F;code&gt; 和 &lt;code&gt;deny&lt;&#x2F;code&gt;，这是两个方法，参数均为操作和过滤器（可选）。例如 &lt;code&gt;(allow signal (target self))&lt;&#x2F;code&gt; 这个语句表达的意思就是：对于&lt;strong&gt;发送信号&lt;&#x2F;strong&gt;且信号的&lt;strong&gt;目标是自己&lt;&#x2F;strong&gt;的操作，&lt;strong&gt;允许执行&lt;&#x2F;strong&gt;。对于某些严格的运行环境，我们还可以使用 &lt;code&gt;(deny default)&lt;&#x2F;code&gt; 禁用掉所有操作，然后使用 &lt;code&gt;allow&lt;&#x2F;code&gt; 方法白名单开启需要的操作。&lt;&#x2F;p&gt;
&lt;p&gt;我们也可以使用通配符来对一组操作进行控制，例如 &lt;code&gt;(deny file-write*)&lt;&#x2F;code&gt; 这个语句会禁用以 &lt;code&gt;file-write&lt;&#x2F;code&gt; 为前缀的所有操作。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jin-cheng-mo-xing&quot;&gt;进程模型&lt;&#x2F;h2&gt;
&lt;p&gt;值得注意的是，Sandbox 在进程上具有继承性，即父进程会将自身的 Sandbox 状态传递给所有由它派生的子进程。这个特性也非常好理解，如果一个进程派生的子进程可以逃逸沙盒，那父进程也相当于间接逃逸沙盒了。如果这样，父进程通过管道控制沙盒外的子进程，这个机制的作用就完全失效了。&lt;&#x2F;p&gt;
&lt;p&gt;而 macOS 中，一个沙盒应用却可以通过 &lt;code&gt;open(1)&lt;&#x2F;code&gt; 或者 &lt;code&gt;NSWorkspace.open(_:)&lt;&#x2F;code&gt; 来以非沙盒模式启动另一个应用。这其实是系统故意留的一个“后门”，因为 Apple 理解这种情况是可控的，毕竟 Mac 作为桌面设备在权限上就会比 iPhone 这样的移动设备宽松。那这个现象是不是违背了 Sandbox 的进程模型呢，其实并没有。&lt;code&gt;open(1)&lt;&#x2F;code&gt; 或其他类似的启动应用方式借助的是 &lt;strong&gt;Launch Services&lt;&#x2F;strong&gt; 这个系统服务，它由 &lt;code&gt;launchd&lt;&#x2F;code&gt; 进程提供，应用通过 Mach IPC 与 &lt;code&gt;launchd&lt;&#x2F;code&gt; 交互，并最终由 &lt;code&gt;launchd&lt;&#x2F;code&gt; 启动应用，即可“逃逸沙盒”（其实在进程关系上，这个“子进程”的父进程是 &lt;code&gt;launchd&lt;&#x2F;code&gt;，与 Sandbox 的进程模型并不冲突）。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;swift-package-cha-jian-qi-dong-guo-cheng-fen-xi&quot;&gt;Swift Package 插件启动过程分析&lt;&#x2F;h1&gt;
&lt;p&gt;我们现在知道 Swift Package Plugin 是运行在沙盒环境中，但是对其具体的 profile 尚不清楚。所以这里我会通过逆向分析 Swift Package Plugin 的启动过程，来提取其运行时的 Sandbox Profile。&lt;&#x2F;p&gt;
&lt;p&gt;首先需要找到一个切入点。由于 Xcode 代码日益庞大，单靠静态分析很难快速定位启动 Swift Package Plugin 的逻辑，因此这里我打算采用动态分析的方法。首先一个进程要想启动，一般会通过 &lt;code&gt;fork&lt;&#x2F;code&gt; + &lt;code&gt;exec*&lt;&#x2F;code&gt; 或者 &lt;code&gt;posix_spawn&lt;&#x2F;code&gt; 这几个系统调用来实现。所以这里我们先用 &lt;code&gt;dtrace&lt;&#x2F;code&gt; 对这几个 syscall 进行拦截（我尝试后发现是 &lt;code&gt;posix_spawn&lt;&#x2F;code&gt;，这里省略其他试验过程了）：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;sudo dtrace -n &amp;#39;syscall::posix_spawn:entry&#x2F;pid == 79228&#x2F; { ustack(); }&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;得到堆栈：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;CPU     ID                    FUNCTION:NAME
&lt;&#x2F;span&gt;&lt;span&gt;  6    655                posix_spawn:entry
&lt;&#x2F;span&gt;&lt;span&gt;              libsystem_kernel.dylib`__posix_spawn+0xa
&lt;&#x2F;span&gt;&lt;span&gt;              Foundation`-[NSConcreteTask launchWithDictionary:error:]+0xe97
&lt;&#x2F;span&gt;&lt;span&gt;              SwiftPM`specialized DefaultPluginScriptRunner.invoke(compiledExec:workingDirectory:writableDirectories:readOnlyDirectories:initialMessage:observabilityScope:callbackQueue:delegate:completion:)+0xb1f
&lt;&#x2F;span&gt;&lt;span&gt;              SwiftPM`closure #1 in DefaultPluginScriptRunner.runPluginScript(sourceFiles:pluginName:initialMessage:toolsVersion:workingDirectory:writableDirectories:readOnlyDirectories:fileSystem:observabilityScope:callbackQueue:delegate:completion:)+0x431
&lt;&#x2F;span&gt;&lt;span&gt;              SwiftPM`partial apply for closure #1 in DefaultPluginScriptRunner.runPluginScript(sourceFiles:pluginName:initialMessage:toolsVersion:workingDirectory:writableDirectories:readOnlyDirectories:fileSystem:observabilityScope:callbackQueue:delegate:completion:)+0x52
&lt;&#x2F;span&gt;&lt;span&gt;              SwiftPM`partial apply for closure #4 in DefaultPluginScriptRunner.compilePluginScript(sourceFiles:pluginName:toolsVersion:observabilityScope:callbackQueue:completion:)+0x59
&lt;&#x2F;span&gt;&lt;span&gt;              SwiftPM`thunk for @escaping @callee_guaranteed () -&amp;gt; ()+0x19
&lt;&#x2F;span&gt;&lt;span&gt;              libdispatch.dylib`_dispatch_call_block_and_release+0xc
&lt;&#x2F;span&gt;&lt;span&gt;              libdispatch.dylib`_dispatch_client_callout+0x8
&lt;&#x2F;span&gt;&lt;span&gt;              libdispatch.dylib`_dispatch_continuation_pop+0x1cc
&lt;&#x2F;span&gt;&lt;span&gt;              libdispatch.dylib`_dispatch_async_redirect_invoke+0x2cc
&lt;&#x2F;span&gt;&lt;span&gt;              libdispatch.dylib`_dispatch_root_queue_drain+0x157
&lt;&#x2F;span&gt;&lt;span&gt;              libdispatch.dylib`_dispatch_worker_thread2+0xa0
&lt;&#x2F;span&gt;&lt;span&gt;              libsystem_pthread.dylib`_pthread_wqthread+0x100
&lt;&#x2F;span&gt;&lt;span&gt;              libsystem_pthread.dylib`start_wqthread+0xf
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里我们就得到了 Swift Package Plugin 的启动逻辑，看起来上层 API 使用的是 &lt;code&gt;NSTask&lt;&#x2F;code&gt;。对于提取 Sandbox Profile 的工作，我们只需拿到 &lt;code&gt;sandbox-exec&lt;&#x2F;code&gt; 的启动参数即可。&lt;&#x2F;p&gt;
&lt;p&gt;在 LLDB 中下断点：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;breakpoint set -n &amp;quot;-[NSConcreteTask launchWithDictionary:error:]&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;断住后检查运行变量：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;* thread #22, queue = &amp;#39;swift.org.swiftpm.shared.concurrent&amp;#39;, stop reason = breakpoint 3.1
&lt;&#x2F;span&gt;&lt;span&gt;    frame #0: 0x00007ff81b68763c Foundation`-[NSConcreteTask launchWithDictionary:error:]
&lt;&#x2F;span&gt;&lt;span&gt;Foundation`-[NSConcreteTask launchWithDictionary:error:]:
&lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt;  0x7ff81b68763c &amp;lt;+0&amp;gt;: pushq  %rbp
&lt;&#x2F;span&gt;&lt;span&gt;    0x7ff81b68763d &amp;lt;+1&amp;gt;: movq   %rsp, %rbp
&lt;&#x2F;span&gt;&lt;span&gt;    0x7ff81b687640 &amp;lt;+4&amp;gt;: pushq  %r15
&lt;&#x2F;span&gt;&lt;span&gt;    0x7ff81b687642 &amp;lt;+6&amp;gt;: pushq  %r14
&lt;&#x2F;span&gt;&lt;span&gt;Target 0: (Xcode) stopped.
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(lldb) po $arg1
&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;NSConcreteTask: 0x600027b5e990&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(lldb) po [$arg1 arguments]
&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Swift.__SwiftDeferredNSArray 0x600009f8c580&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;-p,
&lt;&#x2F;span&gt;&lt;span&gt;(version 1)
&lt;&#x2F;span&gt;&lt;span&gt;(deny default)
&lt;&#x2F;span&gt;&lt;span&gt;(import &amp;quot;system.sb&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;(allow file-read*)
&lt;&#x2F;span&gt;&lt;span&gt;(allow process*)
&lt;&#x2F;span&gt;&lt;span&gt;(allow file-write*
&lt;&#x2F;span&gt;&lt;span&gt;    (subpath &amp;quot;&#x2F;private&#x2F;tmp&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;    (subpath &amp;quot;&#x2F;private&#x2F;var&#x2F;folders&#x2F;18&#x2F;rdgw2vgx4g3g_1qvr7fwfhwh0000gp&#x2F;T&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;(deny file-write*
&lt;&#x2F;span&gt;&lt;span&gt;    (subpath &amp;quot;&#x2F;private&#x2F;var&#x2F;tmp&#x2F;redacted&#x2F;MyLibrary&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;(allow file-write*
&lt;&#x2F;span&gt;&lt;span&gt;    (subpath &amp;quot;&#x2F;Users&#x2F;redacted&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;MyLibrary-dmdwxwcobwwasxgztgazmbufnwcy&#x2F;SourcePackages&#x2F;plugins&#x2F;Test.output&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;    (subpath &amp;quot;&#x2F;Users&#x2F;redacted&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;MyLibrary-dmdwxwcobwwasxgztgazmbufnwcy&#x2F;SourcePackages&#x2F;plugins&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;Users&#x2F;redacted&#x2F;Library&#x2F;Developer&#x2F;Xcode&#x2F;DerivedData&#x2F;MyLibrary-dmdwxwcobwwasxgztgazmbufnwcy&#x2F;SourcePackages&#x2F;plugins&#x2F;Test
&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到插件的运行环境默认禁用了所有权限，而 &lt;code&gt;(import &amp;quot;system.sb&amp;quot;)&lt;&#x2F;code&gt; 只会开启几个系统进程必备的权限，其中不包括任意文件读写和任意 namespace 的 Mach IPC。后面紧接着增加了几个有限制的文件读写操作以及进程操作，方便我们在插件中对文件进行修改，或者使用子进程（如 Git 这种某些操作只有文件 I&#x2F;O 的工具）。&lt;&#x2F;p&gt;
&lt;p&gt;上文中尝试启动计算器之所以失败，并不是因为无法派生进程，而是因为计算器进程无法创建 &lt;code&gt;NSWindow&lt;&#x2F;code&gt;，这个过程需要与 &lt;code&gt;WindowServer&lt;&#x2F;code&gt; 建立 &lt;code&gt;CGSConnectionID&lt;&#x2F;code&gt;，由于插件进程没有 lookup 其 namespace 的权限，因此也无法找到 Mach Port 从而进行通讯。那其他的系统服务无法使用也是同理，大部分系统服务都由名为 &lt;code&gt;xxxxxxd&lt;&#x2F;code&gt; 的 daemon 进程提供，clients 与服务通过 Mach Port 通讯来使用其提供的能力，系统的 frameworks 其实也只是将这些通讯封装成 High-Level APIs 提供给开发者。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;xiao-jie&quot;&gt;小结&lt;&#x2F;h1&gt;
&lt;p&gt;本文简单介绍了 Swift Package Plugin 并探索了它都可以做什么。可以发现，由于沙盒环境的限制，插件可以做的事情还是非常有限的。不过这确实符合 Apple 一贯的做事风格：在一个受限可控的环境下为系统或一方应用提供扩展能力。今年 iPadOS 也很意外的获得了&lt;a href=&quot;https:&#x2F;&#x2F;developer.apple.com&#x2F;documentation&#x2F;driverkit&#x2F;creating_drivers_for_ipados&quot;&gt;加载三方驱动&lt;&#x2F;a&gt;的能力，但可想而知的是，这个驱动也是基于 &lt;code&gt;DriverKit&lt;&#x2F;code&gt; 的受限环境，并没有与内核直接交互的能力。&lt;&#x2F;p&gt;
&lt;p&gt;不过相信今年看到的 Swift Package Plugin 一定不是它的终极形态，就像 SwiftUI 一样，我们可以看到它一点点变得开放和灵活。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>深入 Swift Runtime 之 Protocol 方法派发的实现原理</title>
		<published>2021-12-08T00:00:00+00:00</published>
		<updated>2021-12-08T00:00:00+00:00</updated>
		<link rel="alternate" href="https://unixzii.github.io/swift-runtime-protocol-dispatching/" type="text/html"/>
		<id>https://unixzii.github.io/swift-runtime-protocol-dispatching/</id>
		<content type="html">&lt;p&gt;作为 iOS 开发者，我们都非常熟悉 Objective-C 的消息派发机制，围绕着这个机制也诞生了一系列“黑(miàn)魔(shì)法(tí)”。而到了 Swift 这边我们似乎还都在吃 OC 的老本，继续用着 &lt;code&gt;@objc&lt;&#x2F;code&gt; 来搞事。其实 Swift 在方法派发这件事上也做了很多底层的改变和优化，本文将以 Protocol 的视角来剖析一下 Swift 中的方法派发机制。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;hui-gu-yi-xia-objc-msgsend&quot;&gt;回顾一下 objc_msgSend&lt;&#x2F;h2&gt;
&lt;p&gt;Objective-C 中的万物皆对象，不管是具体的类（如 &lt;code&gt;NSObject *&lt;&#x2F;code&gt;）还是 &lt;code&gt;id&lt;&#x2F;code&gt;，都具有类似的内存结构，即：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;union &lt;&#x2F;span&gt;&lt;span&gt;isa_t {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;isa_t&lt;&#x2F;span&gt;&lt;span&gt;() { }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;isa_t&lt;&#x2F;span&gt;&lt;span&gt;(uintptr_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;value&lt;&#x2F;span&gt;&lt;span&gt;) : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;(value) { }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Class cls;
&lt;&#x2F;span&gt;&lt;span&gt;    uintptr_t bits;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#if defined&lt;&#x2F;span&gt;&lt;span&gt;(ISA_BITFIELD)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        ISA_BITFIELD;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; defined in isa.h
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;objc_object {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;private&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;    isa_t isa;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ivars...
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;而常规的方法调用（除 &lt;code&gt;objc_direct&lt;&#x2F;code&gt; 外）无一例外会走 &lt;code&gt;objc_msgSend&lt;&#x2F;code&gt; 的消息派发流程。因此在 Objective-C 中，是否为 protocol 不会决定方法派发的方式，只会影响编译时的一系列静态检查。&lt;&#x2F;p&gt;
&lt;p&gt;关于 Objective-C 的消息派发机制本文就不过度展开了，有兴趣大家可以自己研究一下。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;c-de-xu-fang-fa-ji-vtable&quot;&gt;C++ 的虚方法及 vtable&lt;&#x2F;h2&gt;
&lt;p&gt;在回到 Swift 之前我们再来看看另一个语言 C++ 是如何做方法派发的，这对理解 Swift 的机制也会有一定帮助和参考意义。&lt;&#x2F;p&gt;
&lt;p&gt;C++ 对象的内存布局相比 Objective-C 对象的更加灵活，根据基类和成员方法的不同会有多种形态。当一个类为“标准布局类型”（&lt;em&gt;StandardLayoutType&lt;&#x2F;em&gt;）时，其内存布局与 C 中 struct 的内存布局一致。而当我们给类增加一个虚方法时，其内存布局就会发生变化，即在最前面增加了 &lt;code&gt; vtable&lt;&#x2F;code&gt; 指针。&lt;&#x2F;p&gt;
&lt;p&gt;与 Objective-C 有一定区别的是，&lt;code&gt;vtable&lt;&#x2F;code&gt; 指针的赋值时机和 OC 对象 &lt;code&gt;isa&lt;&#x2F;code&gt; 的赋值时机不同。由于 OC 对象的构造是显式二段式，也就是 &lt;code&gt;alloc&lt;&#x2F;code&gt; 与 &lt;code&gt;init&lt;&#x2F;code&gt; 可以分开进行，一个对象在 &lt;code&gt;alloc&lt;&#x2F;code&gt; 之后就已经具有类型信息了（即 &lt;code&gt;isa&lt;&#x2F;code&gt; 已被初始化）。而 C++ 对象的构造是空间分配和初始化一体的，并且 C++ 支持 &lt;strong&gt;placement new&lt;&#x2F;strong&gt; 特性来将一个对象初始化到一个已经分配好的内存空间上，因此 C++ 在构造器中对 &lt;code&gt;vtable&lt;&#x2F;code&gt; 指针进行赋值。&lt;&#x2F;p&gt;
&lt;p&gt;我们可以反编译下面的这个代码片段来验证这个过程：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;A &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;public&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;virtual void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;() { }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    A *a = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;new&lt;&#x2F;span&gt;&lt;span&gt; A;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;反编译结果如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;push &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;sub  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;32
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    ; A *a = new A;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;edi&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;operator new(unsigned long)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;pttr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;24&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;call &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;A::A()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt; ; [base object constructor]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    ; ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到对象构造的两段过程，&lt;code&gt;operator new&lt;&#x2F;code&gt; 仅分配空间，接下来直接调用构造器：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;A::A():
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;push   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    movabs &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;offset vtable for A
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcx&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pop    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ret
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;此时 &lt;code&gt;rdi&lt;&#x2F;code&gt; 寄存器为 &lt;code&gt;this&lt;&#x2F;code&gt; 指针（即对象的地址），&lt;code&gt;vtable&lt;&#x2F;code&gt; 指针经过偏移后被赋给对象的首部空间。&lt;&#x2F;p&gt;
&lt;p&gt;接下来来看方法派发的实现，我们直接反编译下面这段代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;A &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;public&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;virtual void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;() &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;B &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;public&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;virtual void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;bar&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;() &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;C &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;public &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;A&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;public &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;B &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;public&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;virtual void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;foo&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;() { }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;virtual void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;bar&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;() { }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    C *c = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;new&lt;&#x2F;span&gt;&lt;span&gt; C;
&lt;&#x2F;span&gt;&lt;span&gt;    c-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;bar&lt;&#x2F;span&gt;&lt;span&gt;();  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 主要关注这里
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;反编译结果如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;push    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;sub     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;32
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;edi&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;call    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;operator new(unsigned long)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;24&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;call    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;C::C() &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;base object constructor&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;24&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt; ; rcx 现在是 c 的指针
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcx&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;      ; rdx 现在是 vtable 指针
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;call    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdx &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;       ; 调用 (vtable + 8) 地址指向的函数
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;xor     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;32
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pop     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ret
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到一次查表的过程，由于类 &lt;code&gt;C&lt;&#x2F;code&gt; 中包含虚方法，方法调用不能采用静态派发方式（为了实现多态），但与 Objective-C 不同的是这个查表过程非常简单，其实就是个数组访问的操作，因此它的性能也会比 Objective-C 的消息派发（查 cache &#x2F; 遍历 method list）快上很多倍。&lt;&#x2F;p&gt;
&lt;p&gt;但假如这里我们稍微变换一下代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    B *b = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;new&lt;&#x2F;span&gt;&lt;span&gt; C;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 变量类型从 C 改成了基类 B
&lt;&#x2F;span&gt;&lt;span&gt;    b-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;bar&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;再看反编译结果：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;main:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;push    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;sub     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;32
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;edi&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;call    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;operator new(unsigned long)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;24&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;call    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;C::C() &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;base object constructor&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;xor     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ecx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ecx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;ecx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;24&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;cmp     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;32&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;je      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.LBB0_2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                   ; 这里有个判空保护，我们直接忽略这行
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;24&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;                    ; this 指针被偏移了 8，赋给 rax（记变量 b）
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;32&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;.LBB0_2:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;32&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt; ; rax 现在等于变量 b 的值
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;      ; 到这里就回到与上个例子相同的查表逻辑
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;call    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcx&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;xor     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;eax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;32
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pop     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ret
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;改变了一下变量的类型，汇编代码竟然有这么大的变化。其实到后面大家就会发现 C++ 与 Swift 类似，会根据代码上下文的不同来改变生成的代码。原因也很简单，我们先来看 C++ 这个现象背后的原理。首先看一下类型 &lt;code&gt;C&lt;&#x2F;code&gt; 的构造器汇编代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;C::C() &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;base object constructor&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;push    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;sub     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;call    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;A::A() &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;base object constructor&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;  ; 调用 A 的构造器
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;call    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;B::B() &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;base object constructor&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;  ; 调用 B 的构造器
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    movabs  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;offset vtable for C
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;48
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdx&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdx&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdx &lt;&#x2F;span&gt;&lt;span&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rcx
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;16
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pop     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;ret
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;由于每个类的构造器都会为那个类型设置 &lt;code&gt;vtable&lt;&#x2F;code&gt; 指针，因此类 &lt;code&gt;C&lt;&#x2F;code&gt; 的对象中会存在 2 个 &lt;code&gt;vtable&lt;&#x2F;code&gt; 指针（第一个被 &lt;code&gt;C&lt;&#x2F;code&gt; 自己的 &lt;code&gt;vtable&lt;&#x2F;code&gt; 指针覆盖了）！最开始的那里例子中，我们调用的是 &lt;code&gt;C::bar&lt;&#x2F;code&gt; 方法，由于接收类型是 &lt;code&gt;C&lt;&#x2F;code&gt;，因此查的也是 C 的 vtable，其内容如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;vtable for C:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    .quad   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    .quad   typeinfo for C
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    .quad   C::foo()
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    .quad   C::bar()
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    .quad   &lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    .quad   typeinfo for C
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    .quad   non&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;virtual thunk to C::bar()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;C&lt;&#x2F;code&gt; 继承了 &lt;code&gt;A&lt;&#x2F;code&gt;、&lt;code&gt;B&lt;&#x2F;code&gt;，因此 &lt;code&gt;vtable for C&lt;&#x2F;code&gt; 是会向下兼容类 &lt;code&gt;A&lt;&#x2F;code&gt; 的 vtable 的（即把 &lt;code&gt;C*&lt;&#x2F;code&gt; 的值赋给 &lt;code&gt;A*&lt;&#x2F;code&gt; 变量与 &lt;code&gt;C*&lt;&#x2F;code&gt; 的值赋给 &lt;code&gt;C*&lt;&#x2F;code&gt; 变量是相同的）。这个特性可以使得一个固定方法在 vtable 中的 index 是固定的。比如调用 &lt;code&gt;C::bar&lt;&#x2F;code&gt;，查找 vtable 下标就是 1，不管其真实类型是什么。&lt;&#x2F;p&gt;
&lt;p&gt;当我们将 &lt;code&gt;C*&lt;&#x2F;code&gt; 的值赋给 &lt;code&gt;B*&lt;&#x2F;code&gt; 的变量时，由于两者的 vtable 结构不兼容（很显然，&lt;code&gt;vtable for C&lt;&#x2F;code&gt; 和 &lt;code&gt;vtable for B&lt;&#x2F;code&gt; 的第一个函数指针不同），我们就不能不做任何处理地把原地址赋值过去，而是要偏移到兼容 &lt;code&gt;vtable for B&lt;&#x2F;code&gt; 的第二个 vtable 地址。这时当我们调用 &lt;code&gt;B::bar&lt;&#x2F;code&gt; 的时候，根据 vtable 内容，就会调用到 &lt;code&gt;non-virtual thunk to C::bar()&lt;&#x2F;code&gt; 函数中。&lt;&#x2F;p&gt;
&lt;p&gt;这里画了一张图，方便大家理解：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;swift-runtime-protocol-dispatching&#x2F;3.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;thunk-dao-di-shi-shi-yao&quot;&gt;thunk 到底是什么？&lt;&#x2F;h3&gt;
&lt;p&gt;看到这里你可能会发现了，这咋 &lt;code&gt;vtable for B&lt;&#x2F;code&gt; 的内容和 &lt;code&gt;vtable for C&lt;&#x2F;code&gt; 的还不一样呢？虽然我们的目的都是调用 &lt;code&gt;C::bar&lt;&#x2F;code&gt;，但是还记得上文说的对象指针偏移吗？由于 &lt;code&gt;C*&lt;&#x2F;code&gt; 赋给 &lt;code&gt;B*&lt;&#x2F;code&gt; 变量时指针发生了偏移，&lt;code&gt;C::bar&lt;&#x2F;code&gt; 拿到的 &lt;code&gt;this&lt;&#x2F;code&gt; 指针就不正确了。所以我们这里不能直接调用 &lt;code&gt;C::bar&lt;&#x2F;code&gt;，而是要先调用一个“跳板”函数，这就是所谓的 thunk。&lt;strong&gt;大家记住这个东西，后面我们分析 Swift 时还会遇到哦。&lt;&#x2F;strong&gt; 我们来看一下这个 thunk 所做的事情：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;asm&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-asm &quot;&gt;&lt;code class=&quot;language-asm&quot; data-lang=&quot;asm&quot;&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;non&lt;&#x2F;span&gt;&lt;span&gt;-&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;virtual thunk to C::bar():
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;push    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rsp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;qword ptr &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp &lt;&#x2F;span&gt;&lt;span&gt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;add     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span&gt;, -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mov     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rdi&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rax&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;             ; 其实只是对 this 做了一次偏移
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pop     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rbp
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;jmp     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;C::bar()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;             ; 尾递归风格调用，不会产生新栈帧
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;所以 thunk 基本上就是对入参（通常是 &lt;code&gt;this&lt;&#x2F;code&gt;）进行一些调整，然后调用真正的函数继续执行。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;back-to-swift&quot;&gt;Back to Swift&lt;&#x2F;h2&gt;
&lt;p&gt;上面我们简单回顾了一下 Objective-C 和 C++ 的方法派发机制，不是很完整，但相信大家能够大致理解其中的思路了。有了这些前置知识之后再来分析 Swift 的方法派发就会容易得多。&lt;&#x2F;p&gt;
&lt;p&gt;但是在正式开始之前我们还是要再认识两个中间语言：SIL、LLVM IR。不像 C++，Swift 的反编译结果比较晦涩，原因一方面是 Swift ABI 结构相比 C++ 会更复杂一些；另一方面是 SIL 的存在会对 Swift 源码做一次去抽象（desugar、lowering），之后生成的 LLVM IR 又会对类 C 的操作做一次优化，最后得到的代码就比较难看出原貌了。因此本文分析 Swift 的时候不去看反汇编代码，而主要去看 LLVM IR，因为在这一层仍然能保留很多内存布局的信息，各种操作相比机器码也更易于理解。关于 SIL 和 LLVM IR，本文不过多展开，大家可以在阅读文章时找到对应的文档自行参考。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tong-guo-jing-tai-pai-fa-chu-shi-sil-llvm-ir&quot;&gt;通过静态派发初识 SIL、LLVM IR&lt;&#x2F;h3&gt;
&lt;p&gt;第一个例子我们先来看看 Swift 中的静态派发，考虑下面的代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;swift&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-swift &quot;&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;protocol&lt;&#x2F;span&gt;&lt;span&gt; SomeRegularProtocol {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;func &lt;&#x2F;span&gt;&lt;span&gt;methodA(_ x: Int) -&amp;gt; Int
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;struct SomeImpl: SomeRegularProtocol {
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; data: Int
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;func &lt;&#x2F;span&gt;&lt;span&gt;methodA(_ x: Int) -&amp;gt; Int {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; data + x
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; impl = SomeImpl(data: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1024&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;impl.methodA(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;由于 struct 不能继承，使用时均是值类型，因此调用的方法地址一定是确定的，我们来分别看看 SIL 和 LLVM IR：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;&#x2F;&#x2F; SIL
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&#x2F; main
&lt;&#x2F;span&gt;&lt;span&gt;sil @main : $@convention(c) (Int32, UnsafeMutablePointer&amp;lt;Optional&amp;lt;UnsafeMutablePointer&amp;lt;Int8&amp;gt;&amp;gt;&amp;gt;) -&amp;gt; Int32 {
&lt;&#x2F;span&gt;&lt;span&gt;bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&amp;lt;Optional&amp;lt;UnsafeMutablePointer&amp;lt;Int8&amp;gt;&amp;gt;&amp;gt;):
&lt;&#x2F;span&gt;&lt;span&gt;  alloc_global @$s4main4implAA8SomeImplVvp        &#x2F;&#x2F; id: %2
&lt;&#x2F;span&gt;&lt;span&gt;  %3 = global_addr @$s4main4implAA8SomeImplVvp : $*SomeImpl &#x2F;&#x2F; users: %10, %9
&lt;&#x2F;span&gt;&lt;span&gt;  %4 = metatype $@thin SomeImpl.Type              &#x2F;&#x2F; user: %8
&lt;&#x2F;span&gt;&lt;span&gt;  %5 = integer_literal $Builtin.Int64, 1024       &#x2F;&#x2F; user: %6
&lt;&#x2F;span&gt;&lt;span&gt;  %6 = struct $Int (%5 : $Builtin.Int64)          &#x2F;&#x2F; user: %8
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; function_ref SomeImpl.init(data:)
&lt;&#x2F;span&gt;&lt;span&gt;  %7 = function_ref @$s4main8SomeImplV4dataACSi_tcfC : $@convention(method) (Int, @thin SomeImpl.Type) -&amp;gt; SomeImpl &#x2F;&#x2F; user: %8
&lt;&#x2F;span&gt;&lt;span&gt;  %8 = apply %7(%6, %4) : $@convention(method) (Int, @thin SomeImpl.Type) -&amp;gt; SomeImpl &#x2F;&#x2F; user: %9
&lt;&#x2F;span&gt;&lt;span&gt;  store %8 to %3 : $*SomeImpl                     &#x2F;&#x2F; id: %9
&lt;&#x2F;span&gt;&lt;span&gt;  %10 = load %3 : $*SomeImpl                      &#x2F;&#x2F; user: %14
&lt;&#x2F;span&gt;&lt;span&gt;  %11 = integer_literal $Builtin.Int64, 42        &#x2F;&#x2F; user: %12
&lt;&#x2F;span&gt;&lt;span&gt;  %12 = struct $Int (%11 : $Builtin.Int64)        &#x2F;&#x2F; user: %14
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; &amp;gt;&amp;gt;&amp;gt;&amp;gt; 这里要调用方法了 &amp;lt;&amp;lt;&amp;lt;&amp;lt;
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; function_ref SomeImpl.methodA(_:)
&lt;&#x2F;span&gt;&lt;span&gt;  %13 = function_ref @$s4main8SomeImplV7methodAyS2iF : $@convention(method) (Int, SomeImpl) -&amp;gt; Int &#x2F;&#x2F; user: %14
&lt;&#x2F;span&gt;&lt;span&gt;  %14 = apply %13(%12, %10) : $@convention(method) (Int, SomeImpl) -&amp;gt; Int
&lt;&#x2F;span&gt;&lt;span&gt;  %15 = integer_literal $Builtin.Int32, 0         &#x2F;&#x2F; user: %16
&lt;&#x2F;span&gt;&lt;span&gt;  %16 = struct $Int32 (%15 : $Builtin.Int32)      &#x2F;&#x2F; user: %17
&lt;&#x2F;span&gt;&lt;span&gt;  return %16 : $Int32                             &#x2F;&#x2F; id: %17
&lt;&#x2F;span&gt;&lt;span&gt;} &#x2F;&#x2F; end sil function &amp;#39;main&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;从 SIL 上就能看出对 &lt;code&gt;SomeImpl.methodA(_:)&lt;&#x2F;code&gt; 的调用就是直接拿到对应方法的函数指针，然后直接调用过去。这里提一下 &lt;code&gt;@convention(method)&lt;&#x2F;code&gt; 这个标注，它会指定一个方法的调用规约（&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Calling_convention&quot;&gt;Calling Convention&lt;&#x2F;a&gt;），这里 &lt;code&gt;method&lt;&#x2F;code&gt; 其实与常规的 &lt;code&gt;System V ABI&lt;&#x2F;code&gt; 差不多，只不过规定了第一个参数是 &lt;code&gt;self&lt;&#x2F;code&gt; 指针。但需要注意的是，SIL 里体现的并不一定是真实的操作，到 LLVM IR 这一层之前仍然会有很多优化，我们来看看上面代码到 LLVM IR 后的结果：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;define i32 @main(i32 %0, i8** %1) #0 {
&lt;&#x2F;span&gt;&lt;span&gt;entry:
&lt;&#x2F;span&gt;&lt;span&gt;  %2 = bitcast i8** %1 to i8*
&lt;&#x2F;span&gt;&lt;span&gt;  %3 = call swiftcc i64 @&amp;quot;$s4main8SomeImplV4dataACSi_tcfC&amp;quot;(i64 1024)
&lt;&#x2F;span&gt;&lt;span&gt;  store i64 %3, i64* getelementptr inbounds (%T4main8SomeImplV, %T4main8SomeImplV* @&amp;quot;$s4main4implAA8SomeImplVvp&amp;quot;, i32 0, i32 0, i32 0), align 8
&lt;&#x2F;span&gt;&lt;span&gt;  %4 = load i64, i64* getelementptr inbounds (%T4main8SomeImplV, %T4main8SomeImplV* @&amp;quot;$s4main4implAA8SomeImplVvp&amp;quot;, i32 0, i32 0, i32 0), align 8
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; 直接调用对应方法，但注意入参
&lt;&#x2F;span&gt;&lt;span&gt;  %5 = call swiftcc i64 @&amp;quot;$s4main8SomeImplV7methodAyS2iF&amp;quot;(i64 42, i64 %4)
&lt;&#x2F;span&gt;&lt;span&gt;  ret i32 0
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到 LLVM IR 的代码比 SIL 简单了很多，很多无用操作会被优化掉。同时我们会发现 &lt;code&gt;SomeImpl.methodA(_:)&lt;&#x2F;code&gt; 方法的入参发生了变化，第二个参数是一个 &lt;code&gt;Int&lt;&#x2F;code&gt;，这也是编译期做的优化，因为这个方法并不需要完整的结构体内容，仅传入需要的数据可以减少拷贝开销。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;protocol-fang-fa-diao-yong-de-shi-xian-yuan-li&quot;&gt;Protocol 方法调用的实现原理&lt;&#x2F;h3&gt;
&lt;p&gt;上面的代码里我们声明了一个 &lt;code&gt;protocol&lt;&#x2F;code&gt;，在正常使用结构体的时候我们没有看到任何动态派发的过程，那我们用 &lt;code&gt;protocol&lt;&#x2F;code&gt; 的方式调用一下看看，首先修改一下代码：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;swift&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-swift &quot;&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;func &lt;&#x2F;span&gt;&lt;span&gt;useRegularProtocol(_ p: SomeRegularProtocol) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; _ = p.methodA(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; impl = SomeImpl(data: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1024&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;useRegularProtocol(impl)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后我们来看一下 SIL：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;&#x2F;&#x2F; main
&lt;&#x2F;span&gt;&lt;span&gt;sil @main : $@convention(c) (Int32, UnsafeMutablePointer&amp;lt;Optional&amp;lt;UnsafeMutablePointer&amp;lt;Int8&amp;gt;&amp;gt;&amp;gt;) -&amp;gt; Int32 {
&lt;&#x2F;span&gt;&lt;span&gt;bb0(%0 : $Int32, %1 : $UnsafeMutablePointer&amp;lt;Optional&amp;lt;UnsafeMutablePointer&amp;lt;Int8&amp;gt;&amp;gt;&amp;gt;):
&lt;&#x2F;span&gt;&lt;span&gt;  alloc_global @$s4main4implAA8SomeImplVvp        &#x2F;&#x2F; id: %2
&lt;&#x2F;span&gt;&lt;span&gt;  %3 = global_addr @$s4main4implAA8SomeImplVvp : $*SomeImpl &#x2F;&#x2F; users: %11, %9
&lt;&#x2F;span&gt;&lt;span&gt;  %4 = metatype $@thin SomeImpl.Type              &#x2F;&#x2F; user: %8
&lt;&#x2F;span&gt;&lt;span&gt;  %5 = integer_literal $Builtin.Int64, 1024       &#x2F;&#x2F; user: %6
&lt;&#x2F;span&gt;&lt;span&gt;  %6 = struct $Int (%5 : $Builtin.Int64)          &#x2F;&#x2F; user: %8
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; function_ref SomeImpl.init(data:)
&lt;&#x2F;span&gt;&lt;span&gt;  %7 = function_ref @$s4main8SomeImplV4dataACSi_tcfC : $@convention(method) (Int, @thin SomeImpl.Type) -&amp;gt; SomeImpl &#x2F;&#x2F; user: %8
&lt;&#x2F;span&gt;&lt;span&gt;  %8 = apply %7(%6, %4) : $@convention(method) (Int, @thin SomeImpl.Type) -&amp;gt; SomeImpl &#x2F;&#x2F; user: %9
&lt;&#x2F;span&gt;&lt;span&gt;  store %8 to %3 : $*SomeImpl                     &#x2F;&#x2F; id: %9
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; 以上都没什么区别
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; 这里开辟了一个存放 protocol 变量的空间
&lt;&#x2F;span&gt;&lt;span&gt;  %10 = alloc_stack $SomeRegularProtocol          &#x2F;&#x2F; users: %17, %16, %15, %12
&lt;&#x2F;span&gt;&lt;span&gt;  %11 = load %3 : $*SomeImpl                      &#x2F;&#x2F; user: %13
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; 做了一个奇怪操作，一会着重看一下
&lt;&#x2F;span&gt;&lt;span&gt;  %12 = init_existential_addr %10 : $*SomeRegularProtocol, $SomeImpl &#x2F;&#x2F; user: %13
&lt;&#x2F;span&gt;&lt;span&gt;  store %11 to %12 : $*SomeImpl                   &#x2F;&#x2F; id: %13
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; function_ref useRegularProtocol(_:)
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; 直接调用我们的 useRegularProtocol 方法
&lt;&#x2F;span&gt;&lt;span&gt;  %14 = function_ref @$s4main18useRegularProtocolyyAA04SomecD0_pF : $@convention(thin) (@in_guaranteed SomeRegularProtocol) -&amp;gt; () &#x2F;&#x2F; user: %15
&lt;&#x2F;span&gt;&lt;span&gt;  %15 = apply %14(%10) : $@convention(thin) (@in_guaranteed SomeRegularProtocol) -&amp;gt; ()
&lt;&#x2F;span&gt;&lt;span&gt;  destroy_addr %10 : $*SomeRegularProtocol        &#x2F;&#x2F; id: %16
&lt;&#x2F;span&gt;&lt;span&gt;  dealloc_stack %10 : $*SomeRegularProtocol       &#x2F;&#x2F; id: %17
&lt;&#x2F;span&gt;&lt;span&gt;  %18 = integer_literal $Builtin.Int32, 0         &#x2F;&#x2F; user: %19
&lt;&#x2F;span&gt;&lt;span&gt;  %19 = struct $Int32 (%18 : $Builtin.Int32)      &#x2F;&#x2F; user: %20
&lt;&#x2F;span&gt;&lt;span&gt;  return %19 : $Int32                             &#x2F;&#x2F; id: %20
&lt;&#x2F;span&gt;&lt;span&gt;} &#x2F;&#x2F; end sil function &amp;#39;main&amp;#39;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面我们遇到了一个新指令：&lt;code&gt;init_existential_addr&lt;&#x2F;code&gt;。不知道是什么，我们查一下 SIL 文档：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Partially initializes the memory referenced by &lt;code&gt;%0&lt;&#x2F;code&gt; with an existential container prepared to contain a value of type &lt;code&gt;$T&lt;&#x2F;code&gt;. The result of the instruction is an address referencing the storage for the contained value, which remains uninitialized. The contained value must be &lt;code&gt;store&lt;&#x2F;code&gt;-d or &lt;code&gt;copy_addr&lt;&#x2F;code&gt;-ed to in order for the existential value to be fully initialized. If the existential container needs to be destroyed while the contained value is uninitialized, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;swift&#x2F;blob&#x2F;main&#x2F;docs&#x2F;SIL.rst#deinit-existential-addr&quot;&gt;deinit_existential_addr&lt;&#x2F;a&gt; must be used to do so. A fully initialized existential container can be destroyed with &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;swift&#x2F;blob&#x2F;main&#x2F;docs&#x2F;SIL.rst#destroy-addr&quot;&gt;destroy_addr&lt;&#x2F;a&gt; as usual. It is undefined behavior to &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;swift&#x2F;blob&#x2F;main&#x2F;docs&#x2F;SIL.rst#destroy-addr&quot;&gt;destroy_addr&lt;&#x2F;a&gt; a partially-initialized existential container.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h4 id=&quot;existential-container&quot;&gt;Existential Container&lt;&#x2F;h4&gt;
&lt;p&gt;这里又出现了一个新概念：&lt;strong&gt;Existential Container&lt;&#x2F;strong&gt;。这个概念大家如果熟悉 Swift 的话应该或多或少听说过，简单来讲它就是一个存放任意类型的变量，你可以把它理解为 &lt;code&gt;Any&lt;&#x2F;code&gt;。为了做到这一点，Swift 在运行时需要知道这个变量的&lt;strong&gt;存储数据（结构体、类本身）&lt;&#x2F;strong&gt;、&lt;strong&gt;类型&lt;&#x2F;strong&gt;、&lt;strong&gt;一系列特征值&lt;&#x2F;strong&gt;。这三要素缺一不可，存储数据好理解，大家可能会问为什么需要类型信息呢？因为 Swift 的 &lt;code&gt;struct&lt;&#x2F;code&gt; 是非常朴素的，它在内存布局中完全无法体现类型信息，如果不是编译时插入了什么上下文信息，我们在运行时拿到一个指向 &lt;code&gt;struct&lt;&#x2F;code&gt; 的地址是不能解析出它的类型名等信息的。而后面的一系列特征值则是我们通常讲的 &lt;strong&gt;witness tables&lt;&#x2F;strong&gt;，分为 &lt;strong&gt;protocol witness table&lt;&#x2F;strong&gt; 和 &lt;strong&gt;value witness table&lt;&#x2F;strong&gt;。他们在 protocol 方法派发过程中起到了至关重要的作用。&lt;&#x2F;p&gt;
&lt;p&gt;Swift 的 ABI 稳定后 &lt;strong&gt;Existential Container&lt;&#x2F;strong&gt; 的内存布局不会发生变化，可以用 C 代码表示为：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;struct OpaqueExistentialContainer {
&lt;&#x2F;span&gt;&lt;span&gt;  void *fixedSizeBuffer[3];
&lt;&#x2F;span&gt;&lt;span&gt;  Metadata *type;
&lt;&#x2F;span&gt;&lt;span&gt;  WitnessTable *witnessTables[NUM_WITNESS_TABLES];
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中 &lt;code&gt;fixedSizeBuffer&lt;&#x2F;code&gt; 存放了 &lt;code&gt;struct&lt;&#x2F;code&gt; 的数据，如果 3 * 8 = 24 个字节放不下会转移到堆内存去，这个机制与 C++ 的 &lt;code&gt;std::string&lt;&#x2F;code&gt; 实现很像，属于 &lt;a href=&quot;https:&#x2F;&#x2F;akrzemi1.wordpress.com&#x2F;2014&#x2F;04&#x2F;14&#x2F;common-optimizations&#x2F;&quot;&gt;&lt;strong&gt;SBO&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; 优化。&lt;&#x2F;p&gt;
&lt;p&gt;另外 &lt;strong&gt;Existential Container&lt;&#x2F;strong&gt; 还有一个变种版本，如果确定一个 &lt;code&gt;protocol&lt;&#x2F;code&gt; 一定是 &lt;code&gt;class&lt;&#x2F;code&gt; 类型时，它的内存布局会变成：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;struct ClassExistentialContainer {
&lt;&#x2F;span&gt;&lt;span&gt;  HeapObject *value;
&lt;&#x2F;span&gt;&lt;span&gt;  WitnessTable *witnessTables[NUM_WITNESS_TABLES];
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;因为 &lt;code&gt;class&lt;&#x2F;code&gt; 对象的内存布局里一定有 &lt;code&gt;Metadata&lt;&#x2F;code&gt; 信息。&lt;&#x2F;p&gt;
&lt;p&gt;到这里其实我们就可以看一下上面那段代码转成 LLVM IR 的结果了（代码很长，你忍一下）：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;define i32 @main(i32 %0, i8** %1) #0 {
&lt;&#x2F;span&gt;&lt;span&gt;entry:
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; 这里已经为 protocol 变量分配栈空间了
&lt;&#x2F;span&gt;&lt;span&gt;  %2 = alloca %T4main19SomeRegularProtocolP, align 8
&lt;&#x2F;span&gt;&lt;span&gt;  %3 = bitcast i8** %1 to i8*
&lt;&#x2F;span&gt;&lt;span&gt;  %4 = call swiftcc i64 @&amp;quot;$s4main8SomeImplV4dataACSi_tcfC&amp;quot;(i64 1024)
&lt;&#x2F;span&gt;&lt;span&gt;  store i64 %4, i64* getelementptr inbounds (%T4main8SomeImplV, %T4main8SomeImplV* @&amp;quot;$s4main4implAA8SomeImplVvp&amp;quot;, i32 0, i32 0, i32 0), align 8
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; 开始为 Existential Container 赋值
&lt;&#x2F;span&gt;&lt;span&gt;  %5 = bitcast %T4main19SomeRegularProtocolP* %2 to i8*
&lt;&#x2F;span&gt;&lt;span&gt;  call void @llvm.lifetime.start.p0i8(i64 40, i8* %5)
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; 注意：%6 是 SomeImpl.data 的值，这里没有立即使用
&lt;&#x2F;span&gt;&lt;span&gt;  %6 = load i64, i64* getelementptr inbounds (%T4main8SomeImplV, %T4main8SomeImplV* @&amp;quot;$s4main4implAA8SomeImplVvp&amp;quot;, i32 0, i32 0, i32 0), align 8
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; %7 是指向 type 的地址，紧接着的 store 指令为其赋了 SomeImpl 的 Metadata
&lt;&#x2F;span&gt;&lt;span&gt;  %7 = getelementptr inbounds %T4main19SomeRegularProtocolP, %T4main19SomeRegularProtocolP* %2, i32 0, i32 1
&lt;&#x2F;span&gt;&lt;span&gt;  store %swift.type* bitcast (i64* getelementptr inbounds (&amp;lt;{ i8**, i64, &amp;lt;{ i32, i32, i32, i32, i32, i32, i32 }&amp;gt;*, i32, [4 x i8] }&amp;gt;, &amp;lt;{ i8**, i64, &amp;lt;{ i32, i32, i32, i32, i32, i32, i32 }&amp;gt;*, i32, [4 x i8] }&amp;gt;* @&amp;quot;$s4main8SomeImplVMf&amp;quot;, i32 0, i32 1) to %swift.type*), %swift.type** %7, align 8
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; %8 是 witnessTables 指向的地址，紧接着的 store 指令为其赋值
&lt;&#x2F;span&gt;&lt;span&gt;  %8 = getelementptr inbounds %T4main19SomeRegularProtocolP, %T4main19SomeRegularProtocolP* %2, i32 0, i32 2
&lt;&#x2F;span&gt;&lt;span&gt;  store i8** getelementptr inbounds ([2 x i8*], [2 x i8*]* @&amp;quot;$s4main8SomeImplVAA0B15RegularProtocolAAWP&amp;quot;, i32 0, i32 0), i8*** %8, align 8
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; 开始为 fixedSizeBuffer 赋值，由于空间足够，这里采用 inline 模式
&lt;&#x2F;span&gt;&lt;span&gt;  %10 = getelementptr inbounds %T4main19SomeRegularProtocolP, %T4main19SomeRegularProtocolP* %2, i32 0, i32 0
&lt;&#x2F;span&gt;&lt;span&gt;  %11 = bitcast [24 x i8]* %10 to %T4main8SomeImplV*
&lt;&#x2F;span&gt;&lt;span&gt;  %.data = getelementptr inbounds %T4main8SomeImplV, %T4main8SomeImplV* %11, i32 0, i32 0
&lt;&#x2F;span&gt;&lt;span&gt;  %.data._value = getelementptr inbounds %TSi, %TSi* %.data, i32 0, i32 0
&lt;&#x2F;span&gt;&lt;span&gt;  store i64 %6, i64* %.data._value, align 8
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; 赋值完毕
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; 直接调用 useRegularProtocol 方法
&lt;&#x2F;span&gt;&lt;span&gt;  call swiftcc void @&amp;quot;$s4main18useRegularProtocolyyAA04SomecD0_pF&amp;quot;(%T4main19SomeRegularProtocolP* noalias nocapture dereferenceable(40) %2)
&lt;&#x2F;span&gt;&lt;span&gt;  %12 = bitcast %T4main19SomeRegularProtocolP* %2 to %__opaque_existential_type_1*
&lt;&#x2F;span&gt;&lt;span&gt;  call void @__swift_destroy_boxed_opaque_existential_1(%__opaque_existential_type_1* %12) #3
&lt;&#x2F;span&gt;&lt;span&gt;  %13 = bitcast %T4main19SomeRegularProtocolP* %2 to i8*
&lt;&#x2F;span&gt;&lt;span&gt;  call void @llvm.lifetime.end.p0i8(i64 40, i8* %13)
&lt;&#x2F;span&gt;&lt;span&gt;  ret i32 0
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面的代码就是 &lt;code&gt;init_existential_addr&lt;&#x2F;code&gt; 所表示的操作了，基本上跟我们的预想一样。到这里我们会发现，Swift 并不会像 C++ 那样，由于一个类定义了虚方法（实现 &lt;code&gt;protocol&lt;&#x2F;code&gt; 方法也算虚方法了），就为它立即生成一个 vtable 并伴随对象生命周期。Swift 将这个过程 defer 到 casting 的时机了，也就是说只有当我们把 &lt;code&gt;SomeImpl&lt;&#x2F;code&gt; 当作 &lt;code&gt;protocol&lt;&#x2F;code&gt; 或 &lt;code&gt;Any&lt;&#x2F;code&gt; 去用的时候才会生成对应的 witness tables，否则这部分开销就不需要。并且生成的 witness tables 不像 C++ 的 vtable 包含了所有的方法，而只会包含对应 protocol 需要的方法。如果你去 demangle pwt 的符号名，会得到 &lt;code&gt;protocol witness table for main.SomeImpl : main.SomeRegularProtocol in main&lt;&#x2F;code&gt;，也就是说这个 pwt 就是 X 类型实现 Y 协议专用的。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;value-witness-table&quot;&gt;Value Witness Table&lt;&#x2F;h4&gt;
&lt;p&gt;除了 pwt 以外还存在着 vwt，前者与 protocol 相关，而后者则与任何 &lt;code&gt;Existential Container&lt;&#x2F;code&gt; 都有关。想象一下，当一个 &lt;code&gt;Any&lt;&#x2F;code&gt; 变量退出作用域时会发生什么。&lt;&#x2F;p&gt;
&lt;p&gt;对于引用类型而言，退出作用域需要减少引用计数；而对于 &lt;code&gt;struct&lt;&#x2F;code&gt; 而言这里就要分情况讨论一下，有引用类型成员的 &lt;code&gt;struct&lt;&#x2F;code&gt; 需要对这些成员做引用计数减少，没有引用类型成员的 &lt;code&gt;struct&lt;&#x2F;code&gt; 则只需要释放内存空间即可。一个 &lt;code&gt;Any&lt;&#x2F;code&gt; 变量如何确定自己执行释放、拷贝等操作时应该做什么，这就取决于 &lt;strong&gt;Value Withness Table&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;这里我们用一个简单的例子展示一下 vwt 的使用场景，就不过多展开了：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;swift&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-swift &quot;&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct&lt;&#x2F;span&gt;&lt;span&gt; SomeImpl: SomeRegularProtocol {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; obj = NSObject()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;func &lt;&#x2F;span&gt;&lt;span&gt;test() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; p: SomeRegularProtocol = SomeImpl(data: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;42&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;IR 如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;define hidden swiftcc void @&amp;quot;$s4main4testyyF&amp;quot;() #0 {
&lt;&#x2F;span&gt;&lt;span&gt;entry:
&lt;&#x2F;span&gt;&lt;span&gt;  %0 = alloca %T4main19SomeRegularProtocolP, align 8
&lt;&#x2F;span&gt;&lt;span&gt;  %1 = bitcast %T4main19SomeRegularProtocolP* %0 to i8*
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; 此处省略 10 多行...
&lt;&#x2F;span&gt;&lt;span&gt;  %10 = bitcast %T4main19SomeRegularProtocolP* %0 to %__opaque_existential_type_1*
&lt;&#x2F;span&gt;&lt;span&gt;  call void @__swift_destroy_boxed_opaque_existential_1(%__opaque_existential_type_1* %10) #2
&lt;&#x2F;span&gt;&lt;span&gt;  %11 = bitcast %T4main19SomeRegularProtocolP* %0 to i8*
&lt;&#x2F;span&gt;&lt;span&gt;  call void @llvm.lifetime.end.p0i8(i64 40, i8* %11)
&lt;&#x2F;span&gt;&lt;span&gt;  ret void
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到编译器在作用域退出时生成了 &lt;code&gt;__swift_destroy_boxed_opaque_existential_1&lt;&#x2F;code&gt; 调用，这个函数实际也是编译器合成的一个行数，我们可以看到它对应的代码：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;; Function Attrs: noinline nounwind
&lt;&#x2F;span&gt;&lt;span&gt;define linkonce_odr hidden void @__swift_destroy_boxed_opaque_existential_1(%__opaque_existential_type_1* %0) #9 {
&lt;&#x2F;span&gt;&lt;span&gt;entry:
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; %1 是类型的 Metadata
&lt;&#x2F;span&gt;&lt;span&gt;  %1 = getelementptr inbounds %__opaque_existential_type_1, %__opaque_existential_type_1* %0, i32 0, i32 1
&lt;&#x2F;span&gt;&lt;span&gt;  %2 = load %swift.type*, %swift.type** %1, align 8
&lt;&#x2F;span&gt;&lt;span&gt;  %3 = getelementptr inbounds %__opaque_existential_type_1, %__opaque_existential_type_1* %0, i32 0, i32 0
&lt;&#x2F;span&gt;&lt;span&gt;  %4 = bitcast %swift.type* %2 to i8***
&lt;&#x2F;span&gt;&lt;span&gt;  %5 = getelementptr inbounds i8**, i8*** %4, i64 -1
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; 从 Metadata 里取出 vwt
&lt;&#x2F;span&gt;&lt;span&gt;  %.valueWitnesses = load i8**, i8*** %5, align 8, !invariant.load !48, !dereferenceable !49
&lt;&#x2F;span&gt;&lt;span&gt;  %6 = bitcast i8** %.valueWitnesses to %swift.vwtable*
&lt;&#x2F;span&gt;&lt;span&gt;  %7 = getelementptr inbounds %swift.vwtable, %swift.vwtable* %6, i32 0, i32 10
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; 从 vwt 中取出 flags 字段（详见下文）
&lt;&#x2F;span&gt;&lt;span&gt;  %flags = load i32, i32* %7, align 8, !invariant.load !48
&lt;&#x2F;span&gt;&lt;span&gt;  %8 = and i32 %flags, 131072
&lt;&#x2F;span&gt;&lt;span&gt;  %flags.isInline = icmp eq i32 %8, 0
&lt;&#x2F;span&gt;&lt;span&gt;  br i1 %flags.isInline, label %inline, label %outline
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&#x2F; 对象的存储数据以 inline 形式存放在 existential container 的 buffer 里
&lt;&#x2F;span&gt;&lt;span&gt;inline:                                           ; preds = %entry
&lt;&#x2F;span&gt;&lt;span&gt;  %9 = bitcast [24 x i8]* %3 to %swift.opaque*
&lt;&#x2F;span&gt;&lt;span&gt;  %10 = bitcast %swift.type* %2 to i8***
&lt;&#x2F;span&gt;&lt;span&gt;  %11 = getelementptr inbounds i8**, i8*** %10, i64 -1
&lt;&#x2F;span&gt;&lt;span&gt;  %.valueWitnesses1 = load i8**, i8*** %11, align 8, !invariant.load !48, !dereferenceable !49
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; 从 vwt 中取出 destroy 操作的函数地址
&lt;&#x2F;span&gt;&lt;span&gt;  %12 = getelementptr inbounds i8*, i8** %.valueWitnesses1, i32 1
&lt;&#x2F;span&gt;&lt;span&gt;  %13 = load i8*, i8** %12, align 8, !invariant.load !48
&lt;&#x2F;span&gt;&lt;span&gt;  %destroy = bitcast i8* %13 to void (%swift.opaque*, %swift.type*)*
&lt;&#x2F;span&gt;&lt;span&gt;  &#x2F;&#x2F; 调用 destroy 函数
&lt;&#x2F;span&gt;&lt;span&gt;  call void %destroy(%swift.opaque* noalias %9, %swift.type* %2) #2
&lt;&#x2F;span&gt;&lt;span&gt;  ret void
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;&#x2F; 对象以 outline 形式分配在堆上，直接走引用计数 release 流程
&lt;&#x2F;span&gt;&lt;span&gt;outline:                                          ; preds = %entry
&lt;&#x2F;span&gt;&lt;span&gt;  %14 = bitcast [24 x i8]* %3 to %swift.refcounted**
&lt;&#x2F;span&gt;&lt;span&gt;  %15 = load %swift.refcounted*, %swift.refcounted** %14, align 8
&lt;&#x2F;span&gt;&lt;span&gt;  call void @swift_release(%swift.refcounted* %15) #2
&lt;&#x2F;span&gt;&lt;span&gt;  ret void
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上面我们看到的 vwt 的数据结构在 Swift ABI 源码中均有体现，大家可以主要参考这个文件：&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;swift&#x2F;blob&#x2F;main&#x2F;include&#x2F;swift&#x2F;ABI&#x2F;Metadata.h#L334&quot;&gt;Metadata.h:334&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;顺便我们再看一下上面这个例子 vwt 里的函数吧，&lt;code&gt;SomeImpl&lt;&#x2F;code&gt; 的 vwt 内容如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;@&amp;quot;$s4main8SomeImplVWV&amp;quot; = internal constant %swift.vwtable {
&lt;&#x2F;span&gt;&lt;span&gt; i8* bitcast (%swift.opaque* ([24 x i8]*, [24 x i8]*, %swift.type*)* @&amp;quot;$s4main8SomeImplVwCP&amp;quot; to i8*),
&lt;&#x2F;span&gt;&lt;span&gt; i8* bitcast (void (%swift.opaque*, %swift.type*)* @&amp;quot;$s4main8SomeImplVwxx&amp;quot; to i8*),
&lt;&#x2F;span&gt;&lt;span&gt; i8* bitcast (%swift.opaque* (%swift.opaque*, %swift.opaque*, %swift.type*)* @&amp;quot;$s4main8SomeImplVwcp&amp;quot; to i8*),
&lt;&#x2F;span&gt;&lt;span&gt; i8* bitcast (%swift.opaque* (%swift.opaque*, %swift.opaque*, %swift.type*)* @&amp;quot;$s4main8SomeImplVwca&amp;quot; to i8*),
&lt;&#x2F;span&gt;&lt;span&gt; i8* bitcast (i8* (i8*, i8*, %swift.type*)* @__swift_memcpy16_8 to i8*),
&lt;&#x2F;span&gt;&lt;span&gt; i8* bitcast (%swift.opaque* (%swift.opaque*, %swift.opaque*, %swift.type*)* @&amp;quot;$s4main8SomeImplVwta&amp;quot; to i8*),
&lt;&#x2F;span&gt;&lt;span&gt; i8* bitcast (i32 (%swift.opaque*, i32, %swift.type*)* @&amp;quot;$s4main8SomeImplVwet&amp;quot; to i8*),
&lt;&#x2F;span&gt;&lt;span&gt; i8* bitcast (void (%swift.opaque*, i32, i32, %swift.type*)* @&amp;quot;$s4main8SomeImplVwst&amp;quot; to i8*),
&lt;&#x2F;span&gt;&lt;span&gt; i64 16, i64 16, i32 65543, i32 2147483647
&lt;&#x2F;span&gt;&lt;span&gt;}, align 8
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中 destroy 对应的函数是 &lt;code&gt;s4main8SomeImplVwxx&lt;&#x2F;code&gt;，其内容如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;; Function Attrs: nounwind
&lt;&#x2F;span&gt;&lt;span&gt;define internal void @&amp;quot;$s4main8SomeImplVwxx&amp;quot;(%swift.opaque* noalias %object, %swift.type* %SomeImpl) #10 {
&lt;&#x2F;span&gt;&lt;span&gt;entry:
&lt;&#x2F;span&gt;&lt;span&gt;  %0 = bitcast %swift.opaque* %object to %T4main8SomeImplV*
&lt;&#x2F;span&gt;&lt;span&gt;  %.obj = getelementptr inbounds %T4main8SomeImplV, %T4main8SomeImplV* %0, i32 0, i32 1
&lt;&#x2F;span&gt;&lt;span&gt;  %toDestroy = load %TSo8NSObjectC*, %TSo8NSObjectC** %.obj, align 8
&lt;&#x2F;span&gt;&lt;span&gt;  %1 = bitcast %TSo8NSObjectC* %toDestroy to i8*
&lt;&#x2F;span&gt;&lt;span&gt;  call void @llvm.objc.release(i8* %1)
&lt;&#x2F;span&gt;&lt;span&gt;  ret void
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以说是非常浅显易懂了。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;thunk&quot;&gt;thunk?&lt;&#x2F;h4&gt;
&lt;p&gt;大家一定在调用栈中见过 &lt;code&gt;protocol witness for X in conformance Y&lt;&#x2F;code&gt; 这个奇怪方法，为什么有了 pwt 还需要一个跳板函数来调用真实的函数呢？&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;swift-runtime-protocol-dispatching&#x2F;4.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;可以回想一下上文中提到的 C++ thunk 和 SIL 优化。回到 “通过静态派发初识 SIL、LLVM IR” 这一小节，Swift 的 struct 方法会有个成员内联的优化，也就是说方法参数中不会传入完整的 struct 对象，而只会传入所需要使用的成员。然而 protocol 调用时并不了解这一细节，调用方仍然需要将完整的 &lt;code&gt;self&lt;&#x2F;code&gt; 指针作为一个参数传入。这里编译器有两个选择：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;生成两份方法代码，分别适配直接调用和 protocol 调用&lt;&#x2F;li&gt;
&lt;li&gt;生成跳板函数，在跳板函数中提取成员后调用原方法&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;显然第二种方法更为高效。&lt;&#x2F;p&gt;
&lt;p&gt;实际上 thunk 函数的作用还有很多，大家开发 OC 日常可能会用到的 Method Swizzling 也会用到类似 thunk 的技术，如果有兴趣也可以深入研究一下，还是非常有意思的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h2&gt;
&lt;p&gt;本文从 Objective-C、C++ 切入，以 SIL、LLVM IR 为“抓手”详细分析了 Swift Protocol 的方法派发原理，从中我们可以发现语言之间的很多共性，例如通过 thunk 来适配不同的调用方，通过函数表实现多态等。现代的很多编程语言实际上存在非常多相似的实现思路，比如 Golang 的 &lt;code&gt;interface{}&lt;&#x2F;code&gt; 也是用了跟 Swift Existential Container 一样的结构，只不过 Golang 称之为 &lt;strong&gt;fat pointer&lt;&#x2F;strong&gt;。通过这种方法能极大地减少堆内存的分配开销，使抽象的成本更低。&lt;&#x2F;p&gt;
&lt;p&gt;同时我们也注意到了，相比 Objective-C 这门古老的语言，Swift 等现代语言会把更多的优化和底层实现放在编译期进行，减少运行时所需的信息，这也是为什么大家感觉在 Swift 里做反射这类操作更难了。其实不是 Swift 不存储元信息，只是 Apple 不再希望开发者通过运行时的特性来完成业务逻辑，开发者越依赖运行时信息，未来底层的优化机会就会越少。同理，G 家的 Flutter 也不允许开发者在 Dart 里使用反射，因为会影响 tree shaking 优化。Swift ABI 现在已经稳定，我们仍然可以在开发阶段借助运行时信息来做一些调试用途的事情。在实现业务逻辑上，还是应该优先选择编译期的解决方案。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>深入 Swift Runtime 之 TrailingObjects</title>
		<published>2021-12-06T00:00:00+00:00</published>
		<updated>2021-12-06T00:00:00+00:00</updated>
		<link rel="alternate" href="https://unixzii.github.io/swift-runtime-trailing-objects/" type="text/html"/>
		<id>https://unixzii.github.io/swift-runtime-trailing-objects/</id>
		<content type="html">&lt;p&gt;Swift Runtime 底层结构和行为大量使用 C++ 开发，因此如果想要深入分析 Runtime 的原理或者 ABI 的内存布局等就需要对这部分 C++ 代码有所了解。Swift 的 C++ 源码中使用了很多“黑魔法”，尤其是模板，可能对 C++ 新手来说会比较劝退。本文就带大家深入浅出地分析其源码中的一个模板结构 &lt;code&gt;TrailingObjects&lt;&#x2F;code&gt;，揭开 Swift Runtime 的冰山一角。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jian-dan-liao-liao-swift-abi&quot;&gt;简单聊聊 Swift ABI&lt;&#x2F;h2&gt;
&lt;p&gt;据 Apple 称，自 Swift 5.0 起，其 ABI 在 Apple 平台上就稳定了，这意味着 Swift 5.0 的编译产物在内存布局、runtime 调用上就不会发生变化了，也意味着你可以更换任意一个 ABI 兼容的标准库（&lt;code&gt;libSwiftCore.dylib&lt;&#x2F;code&gt;）。因此在新的 iOS 版本中，app 就可以不将额外的 Swift Runtime 内嵌到 bundle 中了，从而节省了一部分包体积。&lt;&#x2F;p&gt;
&lt;p&gt;ABI 的稳定也意味着我们可以直接更换编译好的可执行二进制产物的 Swift Runtime，并通过自己编译的 runtime 来调试其内部数据结构和行为。亦或者直接将 Swift Runtime 的头文件引入自己的工程中来调用（毕竟内存布局是一样的，所有的结构可以完全匹配上）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ru-he-diao-shi-runtime&quot;&gt;如何调试 Runtime&lt;&#x2F;h2&gt;
&lt;p&gt;自己编译好 Swift 工具链后可以得到可调试的 &lt;code&gt;libSwiftCore.dylib&lt;&#x2F;code&gt;， 但直接 link 它的话在运行时还是会加在系统中的动态库，因为产物默认的 &lt;code&gt;LC_ID_DYLIB&lt;&#x2F;code&gt; 是系统路径，这里为了方便我们可以直接通过 &lt;code&gt;install_name_tool -change&lt;&#x2F;code&gt; 更换可执行的 &lt;code&gt;LC_LOAD_DYLIB&lt;&#x2F;code&gt; command，让它加载我们的 runtime。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;swift-runtime-trailing-objects&#x2F;1.png&quot; alt=&quot;otool&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;更改好后我们在 runtime 代码里打一个断点，发现调试器可以成功断在里面并且可以随意访问变量和步进执行。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;swift-runtime-trailing-objects&#x2F;2.png&quot; alt=&quot;Xcode Breakpoints&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ren-shi-di-yi-ge-runtime-jie-gou&quot;&gt;认识第一个 Runtime 结构&lt;&#x2F;h2&gt;
&lt;p&gt;Swift Runtime 中的数据结构很多，有运行时产生的，也有编译链接时产生的。我们这里来看一个编译时产生的重要结构：&lt;code&gt;Metadata&lt;&#x2F;code&gt;。它表示一个类型的元数据，runtime 的方方面面都依赖这个信息。在 Swift 中的表示为 &lt;code&gt;T.Type&lt;&#x2F;code&gt;，即 &lt;code&gt;T.self&lt;&#x2F;code&gt; 的返回值类型。我们可以通过反编译下面这个简单的代码片段来看一下它在运行时是怎么获取的：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Swift&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-Swift &quot;&gt;&lt;code class=&quot;language-Swift&quot; data-lang=&quot;Swift&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;func &lt;&#x2F;span&gt;&lt;span&gt;takeType&amp;lt;T&amp;gt;(_ t: T.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;Type&lt;&#x2F;span&gt;&lt;span&gt;) { }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;takeType(Foo.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;)  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Line to decompile
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;反编译结果如下：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;swift-runtime-trailing-objects&#x2F;3.png&quot; alt=&quot;Hopper&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;可以看到 takeType 的第一个参数为一个指针，指向了 &lt;code&gt;_$s4test3FooVMf&lt;&#x2F;code&gt; 这个符号加偏移量 8 的地址。这个符号 demangle 之后的符号名为 &lt;code&gt;full type metadata for test.Foo&lt;&#x2F;code&gt;，内容如下：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;swift-runtime-trailing-objects&#x2F;4.png&quot; alt=&quot;Hopper&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;其 + 8 后的地址为另一个符号，但内容 hopper 无法解析。&lt;&#x2F;p&gt;
&lt;p&gt;之前我们说过，&lt;code&gt;Metadata&lt;&#x2F;code&gt; 结构对应的 Swift 类型为 &lt;code&gt;T.Type&lt;&#x2F;code&gt;，那么这个 &lt;code&gt;_$s4test3FooVMf + 8&lt;&#x2F;code&gt; 的地址必然存放了与 &lt;code&gt;Metadata&lt;&#x2F;code&gt; 布局相同的内容。&lt;&#x2F;p&gt;
&lt;p&gt;我们来看一下 &lt;code&gt;Metadata&lt;&#x2F;code&gt; 在 C++ 代码中的定义（已简化，完整代码链接也贴在了文章最后）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Runtime&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;TargetMetadata;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;using &lt;&#x2F;span&gt;&lt;span&gt;Metadata = TargetMetadata&amp;lt;InProcess&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Runtime&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;TargetMetadata {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;using &lt;&#x2F;span&gt;&lt;span&gt;StoredPointer = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Runtime::StoredPointer;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; The basic header type.
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typedef&lt;&#x2F;span&gt;&lt;span&gt; TargetTypeMetadataHeader&amp;lt;Runtime&amp;gt; HeaderType;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;constexpr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TargetMetadata&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Kind&lt;&#x2F;span&gt;&lt;span&gt;(static_cast&amp;lt;StoredPointer&amp;gt;(MetadataKind::Class)) {}
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;constexpr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TargetMetadata&lt;&#x2F;span&gt;&lt;span&gt;(MetadataKind &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Kind&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Kind&lt;&#x2F;span&gt;&lt;span&gt;(static_cast&amp;lt;StoredPointer&amp;gt;(Kind)) {}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;private&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; The kind. Only valid for non-class metadata; getKind() must be used to get
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; the kind value.
&lt;&#x2F;span&gt;&lt;span&gt;  StoredPointer Kind;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;public&lt;&#x2F;span&gt;&lt;span&gt;:
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; Get the metadata kind.
&lt;&#x2F;span&gt;&lt;span&gt;  MetadataKind &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;getKind&lt;&#x2F;span&gt;&lt;span&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;getEnumeratedMetadataKind&lt;&#x2F;span&gt;&lt;span&gt;(Kind);
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;  
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; Set the metadata kind.
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;setKind&lt;&#x2F;span&gt;&lt;span&gt;(MetadataKind &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;kind&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    Kind = static_cast&amp;lt;StoredPointer&amp;gt;(kind);
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;通过类型的定义可以看到，这个 &lt;code&gt;Metadata&lt;&#x2F;code&gt; 是 &lt;code&gt;TargetMetadata&amp;lt;InProcess&amp;gt;&lt;&#x2F;code&gt; 的 type-alias，为了方便我们后续都用 &lt;code&gt;Metadata&lt;&#x2F;code&gt; 代指后者。其存储字段只有一个 &lt;code&gt;StoredPointer&lt;&#x2F;code&gt; 类型的 &lt;code&gt;Kind&lt;&#x2F;code&gt; 变量。&lt;code&gt;StoredPointer&lt;&#x2F;code&gt; 定义在 Runtime 泛型中，代入 &lt;code&gt;InProcess&lt;&#x2F;code&gt; 可以看到定义（已简化）：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;InProcess {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static constexpr &lt;&#x2F;span&gt;&lt;span&gt;size_t PointerSize = sizeof(uintptr_t);
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;using &lt;&#x2F;span&gt;&lt;span&gt;StoredPointer = uintptr_t;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;using &lt;&#x2F;span&gt;&lt;span&gt;StoredSignedPointer = uintptr_t;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;using &lt;&#x2F;span&gt;&lt;span&gt;StoredSize = size_t;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;using &lt;&#x2F;span&gt;&lt;span&gt;StoredPointerDifference = ptrdiff_t;
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我们再来看下 MetadataKind 的定义：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const unsigned&lt;&#x2F;span&gt;&lt;span&gt; MetadataKindIsNonHeap = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x200&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;enum class &lt;&#x2F;span&gt;&lt;span&gt;MetadataKind : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;uint32_t &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;METADATAKIND&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;value&lt;&#x2F;span&gt;&lt;span&gt;) name = value,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;ABSTRACTMETADATAKIND&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;start&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;end&lt;&#x2F;span&gt;&lt;span&gt;)                                 \
&lt;&#x2F;span&gt;&lt;span&gt;  name##_Start = start, name##_End = end,
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; content of: #include &amp;quot;MetadataKind.def&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#ifndef&lt;&#x2F;span&gt;&lt;span&gt; NOMINALTYPEMETADATAKIND
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#define &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;NOMINALTYPEMETADATAKIND&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Name&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Value&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;METADATAKIND&lt;&#x2F;span&gt;&lt;span&gt;(Name, Value)
&lt;&#x2F;span&gt;&lt;span&gt;	&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#endif
&lt;&#x2F;span&gt;&lt;span&gt;  
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; A class type.
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;NOMINALTYPEMETADATAKIND&lt;&#x2F;span&gt;&lt;span&gt;(Class, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; A struct type.
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;NOMINALTYPEMETADATAKIND&lt;&#x2F;span&gt;&lt;span&gt;(Struct, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span&gt;| MetadataKindIsNonHeap)
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; An enum type.
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; If we add reference enums, that needs to go here.
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;NOMINALTYPEMETADATAKIND&lt;&#x2F;span&gt;&lt;span&gt;(Enum, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;| MetadataKindIsNonHeap)
&lt;&#x2F;span&gt;&lt;span&gt;  
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;刚才反编译看到的那段未知数据在内存布局上就与这个 &lt;code&gt;Kind&lt;&#x2F;code&gt; 对应，按值匹配即为 &lt;code&gt;Struct&lt;&#x2F;code&gt;。到这里大家可能就会好奇了，为什么 &lt;code&gt;_$s4test3FooVMf + 8&lt;&#x2F;code&gt; 才是 &lt;code&gt;Metadata&lt;&#x2F;code&gt; 呢，那 &lt;code&gt;_$s4test3FooVMf&lt;&#x2F;code&gt; 对应的是什么呢？这里先不展开，相信大家按照本文的思路也能自己找到它的定义。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;metadata-zi-lei&quot;&gt;Metadata 子类？&lt;&#x2F;h2&gt;
&lt;p&gt;到这里我们已经正式将一个类型横跨 Swift - 二进制 - C++ 进行了对接，接下来我们就来继续分析其他的结构。通过 &lt;code&gt;Metadata&lt;&#x2F;code&gt; 的定义我们应该能猜到，它不可能承载所有的信息，那么不同类型的详细信息都在哪里呢？这就要引出它的“子类”们了。以本文分析的 struct 为例，其真实 &lt;code&gt;Metadata&lt;&#x2F;code&gt; 类型是 &lt;code&gt;StructMetadata&lt;&#x2F;code&gt; (aka. &lt;code&gt;TargetStructMetadata&amp;lt;InProcess&amp;gt;&lt;&#x2F;code&gt;)，结构定义及类型层次如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Runtime&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;TargetValueMetadata : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;public &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;TargetMetadata&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Runtime&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;using &lt;&#x2F;span&gt;&lt;span&gt;StoredPointer = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Runtime::StoredPointer;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;TargetValueMetadata&lt;&#x2F;span&gt;&lt;span&gt;(MetadataKind &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Kind&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; TargetTypeContextDescriptor&amp;lt;Runtime&amp;gt; *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;description&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;      : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;TargetMetadata&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Runtime&amp;gt;(Kind), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Description&lt;&#x2F;span&gt;&lt;span&gt;(description) {}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; An out-of-line description of the type.
&lt;&#x2F;span&gt;&lt;span&gt;  TargetSignedPointer&amp;lt;Runtime, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; TargetValueTypeDescriptor&amp;lt;Runtime&amp;gt; * __ptrauth_swift_type_descriptor&amp;gt; Description;
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Runtime&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;TargetStructMetadata : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;public &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;TargetValueMetadata&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Runtime&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;using &lt;&#x2F;span&gt;&lt;span&gt;StoredPointer = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Runtime::StoredPointer;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;using&lt;&#x2F;span&gt;&lt;span&gt; TargetValueMetadata&amp;lt;Runtime&amp;gt;::TargetValueMetadata;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; TargetStructDescriptor&amp;lt;Runtime&amp;gt; *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;getDescription&lt;&#x2F;span&gt;&lt;span&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;llvm::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;cast&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;TargetStructDescriptor&amp;lt;Runtime&amp;gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Description&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; Get a pointer to the field offset vector, if present, or null.
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;uint32_t *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;getFieldOffsets&lt;&#x2F;span&gt;&lt;span&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; offset = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;getDescription&lt;&#x2F;span&gt;&lt;span&gt;()-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;FieldOffsetVectorOffset&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(offset == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;nullptr&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; asWords = reinterpret_cast&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const void &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt;*&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;reinterpret_cast&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;uint32_t *&amp;gt;(asWords + offset);
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到 &lt;code&gt;StructMetadata&lt;&#x2F;code&gt; 本质上与 &lt;code&gt;ValueMetadata&lt;&#x2F;code&gt; 内存布局一致，仅当类型不同时有不同的运行时行为。&lt;code&gt;ValueMetadata&lt;&#x2F;code&gt; 在公共的 &lt;code&gt;Kind&lt;&#x2F;code&gt; 字段下又增加了 &lt;code&gt;Description&lt;&#x2F;code&gt; 字段，通过类型分析也是一个指针。这个字段指向了一个外联的描述结构，这个结构也是本文要重点分析的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;targetstructdescriptor&quot;&gt;TargetStructDescriptor&lt;&#x2F;h2&gt;
&lt;p&gt;先看定义：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; Runtime&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TargetStructDescriptor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;final
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;public &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;TargetValueTypeDescriptor&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;Runtime&amp;gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;public &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;TrailingGenericContextObjects&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;TargetStructDescriptor&amp;lt;Runtime&amp;gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                            TargetTypeGenericContextDescriptorHeader,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;*additional trailing objects*&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                            TargetForeignMetadataInitialization&amp;lt;Runtime&amp;gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                            TargetSingletonMetadataInitialization&amp;lt;Runtime&amp;gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                            TargetCanonicalSpecializedMetadatasListCount&amp;lt;Runtime&amp;gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                            TargetCanonicalSpecializedMetadatasListEntry&amp;lt;Runtime&amp;gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                            TargetCanonicalSpecializedMetadatasCachingOnceToken&amp;lt;Runtime&amp;gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;说实话，刚开始看到这个类型我也懵了一下，但实际并没有看上去那么复杂。我们来一点一点分析。&lt;&#x2F;p&gt;
&lt;p&gt;首先第一个父类 &lt;code&gt;TargetValueTypeDescriptor&lt;&#x2F;code&gt;，它其实是一个很简单的类型，提供了一些公共字段和行为，继承关系如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;TargetValueTypeDescriptor
&lt;&#x2F;span&gt;&lt;span&gt;`-- TargetTypeContextDescriptor
&lt;&#x2F;span&gt;&lt;span&gt;    `-- TargetContextDescriptor
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;比较麻烦的是它的第二个父类 &lt;code&gt;TrailingGenericContextObjects&amp;lt;&amp;amp;@#?%^@*&amp;gt;&lt;&#x2F;code&gt;，这个类型的模板参数很多且雷同，一看就是个 &lt;em&gt;variadic template&lt;&#x2F;em&gt;，我们还是直接看定义：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class&lt;&#x2F;span&gt;&lt;span&gt; Self,
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class&lt;&#x2F;span&gt;&lt;span&gt; TargetGenericContextHeaderType =
&lt;&#x2F;span&gt;&lt;span&gt;           TargetGenericContextDescriptorHeader,
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt;... FollowingTrailingObjects&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TrailingGenericContextObjects&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class&lt;&#x2F;span&gt;&lt;span&gt; Runtime,
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class&lt;&#x2F;span&gt;&lt;span&gt; TargetSelf,
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class&lt;&#x2F;span&gt;&lt;span&gt; TargetGenericContextHeaderType,
&lt;&#x2F;span&gt;&lt;span&gt;         &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt;... FollowingTrailingObjects&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TrailingGenericContextObjects&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;TargetSelf&amp;lt;Runtime&amp;gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                                    TargetGenericContextHeaderType,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                                    FollowingTrailingObjects&lt;&#x2F;span&gt;&lt;span&gt;...&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;gt; :
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;protected &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;swift::ABI::TrailingObjects&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;TargetSelf&amp;lt;Runtime&amp;gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      TargetGenericContextHeaderType&amp;lt;Runtime&amp;gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      GenericParamDescriptor,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      TargetGenericRequirementDescriptor&amp;lt;Runtime&amp;gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      FollowingTrailingObjects&lt;&#x2F;span&gt;&lt;span&gt;...&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* ... *&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;通过定义可知，&lt;code&gt;TrailingGenericContextObjects&lt;&#x2F;code&gt; 在使用时有两个定参（&lt;code&gt;Self&lt;&#x2F;code&gt;、&lt;code&gt;TargetGenericContextHeaderType&lt;&#x2F;code&gt;）和一个不定参模板参数（&lt;code&gt;FollowingTrailingObjects...&lt;&#x2F;code&gt;），下面有一个偏特化定义，主要作用是萃取 &lt;code&gt;Runtime&lt;&#x2F;code&gt; 参数以便后用。这个偏特化的定义直接继承了 &lt;code&gt;TrailingObjects&lt;&#x2F;code&gt;，即我们接下来要重点分析的类型，实现如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; BaseTy, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt;... TrailingTys&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TrailingObjects &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;private &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;trailing_objects_internal::TrailingObjectsImpl&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                            trailing_objects_internal::AlignmentCalcHelper&amp;lt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                                TrailingTys&lt;&#x2F;span&gt;&lt;span&gt;...&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;gt;::Alignment,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                            BaseTy, TrailingObjects&amp;lt;BaseTy, TrailingTys&lt;&#x2F;span&gt;&lt;span&gt;...&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                            BaseTy, TrailingTys&lt;&#x2F;span&gt;&lt;span&gt;...&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;private&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; These two methods are the base of the recursion for this method.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; BaseTy &lt;&#x2F;span&gt;&lt;span&gt;*
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;getTrailingObjectsImpl&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; BaseTy &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Obj&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                         TrailingObjectsBase::OverloadToken&amp;lt;BaseTy&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; Obj;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; BaseTy &lt;&#x2F;span&gt;&lt;span&gt;*
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;getTrailingObjectsImpl&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(BaseTy &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Obj&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                         TrailingObjectsBase::OverloadToken&amp;lt;BaseTy&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; Obj;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;public&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; Returns a pointer to the trailing object array of the given type
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; (which must be one of those specified in the class template). The
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; array may have zero or more elements in it.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; T&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; T &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;getTrailingObjects&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Forwards to an impl function with overloads, since member
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; function templates can&amp;#39;t be specialized.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;getTrailingObjectsImpl&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;        &lt;&#x2F;span&gt;&lt;span&gt;static_cast&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; BaseTy &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;),
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;        TrailingObjectsBase::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;OverloadToken&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;T&amp;gt;());
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;通过模板参数的声明我们可以大致猜想到，这个类型除了第一个模板参数（&lt;code&gt;BaseTy&lt;&#x2F;code&gt;），其他不定参模板参数的角色都是相同的，对应到 &lt;code&gt;TrailingGenericContextObjects&lt;&#x2F;code&gt; 类型上，除了第一个 &lt;code&gt;TargetSelf&amp;lt;Runtime&amp;gt;&lt;&#x2F;code&gt; 参数，其他参数 &lt;code&gt;TrailingObjects&lt;&#x2F;code&gt; 并不实际感知。那么就可以得出结论，&lt;code&gt;TrailingGenericContextObjects&lt;&#x2F;code&gt; 实际上就是为它的参数追加上一部分额外参数（与 Swift 泛型相关），传递给 &lt;code&gt;TrailingObjects&lt;&#x2F;code&gt; 使用，充当了一层装饰器。这里我们可以先忽略它的作用。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;trailingobjects&quot;&gt;TrailingObjects&lt;&#x2F;h2&gt;
&lt;p&gt;接下来我们继续分析 &lt;code&gt;TrailingObjects&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;通过前面的代码，我们可以看到这个类型定义了一些方法，但没有任何存储字段，并且可以看到它对接受的模板参数进行了一些类型计算，又传给了父类作为模板参数。其父类是 &lt;code&gt;TrailingObjects&lt;&#x2F;code&gt; 的核心实现，我们也一块来看一下定义：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; Align, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; BaseTy, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; TopTrailingObj, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; PrevTy,
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt;... MoreTys&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TrailingObjectsImpl &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; The main template definition is never used -- the two
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; specializations cover all possibilities.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; Align, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; BaseTy, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; TopTrailingObj, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; PrevTy,
&lt;&#x2F;span&gt;&lt;span&gt;          &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; NextTy, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt;... MoreTys&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TrailingObjectsImpl&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;Align, BaseTy, TopTrailingObj, PrevTy, NextTy,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                          MoreTys&lt;&#x2F;span&gt;&lt;span&gt;...&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;public &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;TrailingObjectsImpl&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;Align, BaseTy, TopTrailingObj, NextTy,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                                 MoreTys&lt;&#x2F;span&gt;&lt;span&gt;...&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;*
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;  trailing_objects_internal::TrailingObjectsImpl&amp;lt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    trailing_objects_internal::AlignmentCalcHelper&amp;lt;TrailingTys...&amp;gt;::Alignment,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    BaseTy,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    TrailingObjects&amp;lt;BaseTy, TrailingTys...&amp;gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    BaseTy,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    TrailingTys...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;  &amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;*&#x2F;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这个类型继承了它自己，因此这是一个递归模板，&lt;strong&gt;是处理不定参模板的一种手段&lt;&#x2F;strong&gt;。在这种模式下，每一层类型都可以获取到参数列表中的一项，然后把剩下的参数传给父类，那么它的父类就可以处理下一项，然后继续把剩下的参数传给父类...&lt;&#x2F;p&gt;
&lt;p&gt;很像 Lisp 和 Haskell 等 FP 语言处理列表的方式，有兴趣的同学可以看看这篇文章：&lt;a href=&quot;http:&#x2F;&#x2F;learnyouahaskell.com&#x2F;recursion#maximum-awesome&quot;&gt;Learn You a Haskell for Great Good! - Recursion&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;但是自己继承自己如果没有终止条件就会死循环，因此一定存在一个(偏)特化用于终止递归：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; The base case of the TrailingObjectsImpl inheritance recursion,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; when there&amp;#39;s no more trailing types.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span&gt; Align, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; BaseTy, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; TopTrailingObj, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; PrevTy&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TrailingObjectsImpl&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;Align, BaseTy, TopTrailingObj, PrevTy&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;public &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;TrailingObjectsAligner&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;Align&amp;gt; {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;*
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;  matching TrailingObjectsImpl&amp;lt;Align, BaseTy, TopTrailingObj, NextTy, MoreTys...&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;    with MoreTys = []
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;*&#x2F;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;整个模板递归展开的过程大家可以使用 &lt;strong&gt;cppinsights&lt;&#x2F;strong&gt; 这个工具来查看，我这里已经做好了一个可编译的版本可以直接打开：&lt;a href=&quot;https:&#x2F;&#x2F;cppinsights.io&#x2F;s&#x2F;8de0f488&quot;&gt;https:&#x2F;&#x2F;cppinsights.io&#x2F;s&#x2F;8de0f488&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;接下来我们来看递归的每层类型为最终的类型添加了什么内容：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TrailingObjectsImpl&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;Align, BaseTy, TopTrailingObj, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* 顶层完整类型 *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    PrevTy, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* 上一层处理的模板参数 *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    NextTy, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* 当前层处理的模板参数 *&#x2F;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    MoreTys&lt;&#x2F;span&gt;&lt;span&gt;... &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* 下一层处理的模板参数列表 *&#x2F;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;* : ... *&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;protected&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; NextTy &lt;&#x2F;span&gt;&lt;span&gt;*
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;getTrailingObjectsImpl&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; BaseTy &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Obj&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                         TrailingObjectsBase::OverloadToken&amp;lt;NextTy&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;auto &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;Ptr &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;TopTrailingObj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;getTrailingObjectsImpl&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                    Obj, TrailingObjectsBase::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;OverloadToken&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;PrevTy&amp;gt;()) &lt;&#x2F;span&gt;&lt;span&gt;+
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                TopTrailingObj::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;callNumTrailingObjects&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;                    Obj, TrailingObjectsBase::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;OverloadToken&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;PrevTy&amp;gt;());
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;requiresRealignment&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;())
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;reinterpret_cast&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; NextTy &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;gt;(
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;          llvm::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;alignAddr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(Ptr, llvm::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Align&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span&gt;alignof&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(NextTy))));
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;reinterpret_cast&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; NextTy &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;gt;(Ptr);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到每一层都会有一个 &lt;code&gt;getTrailingObjectsImpl&lt;&#x2F;code&gt; 方法的重载，这个就是 &lt;code&gt;TrailingObjectsImpl&lt;&#x2F;code&gt; 最核心的方法，可以看到它能够返回当前层所处理的类型。同时他接受一个比较特殊的参数 &lt;code&gt;OverloadToken&lt;&#x2F;code&gt;，之所以存在这个参数是因为 C++ 不支持仅返回值不同的函数重载，也不支持模板函数的(偏)特化，因此这个参数是用来帮助编译器确定我们需要的重载版本的，函数体内并不需要关心其内容。其他语言中也有类似的技术，比如 Rust 的 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;marker&#x2F;struct.PhantomData.html&quot;&gt;PhantomData&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;继续来看函数的实现，它调用了 &lt;code&gt;TopTrailingObj&lt;&#x2F;code&gt; 的 &lt;code&gt;getTrailingObjectsImpl&lt;&#x2F;code&gt; 方法并传入了 &lt;code&gt;PrevTy&lt;&#x2F;code&gt; 构造的 &lt;code&gt;OverloadToken&lt;&#x2F;code&gt;。这里 &lt;code&gt;TopTrailingObj&lt;&#x2F;code&gt; 表示一个完整类型，可以像外界一样获取到整个类型层次中的所有成员。很明显这里其实也是一个递归调用，&lt;code&gt;PrevTy&lt;&#x2F;code&gt; 向前追溯是 &lt;code&gt;BaseTy&lt;&#x2F;code&gt;，所以我们看看返回 &lt;code&gt;BaseTy&lt;&#x2F;code&gt; 的重载版本，它位于 &lt;code&gt;TrailingObjects&lt;&#x2F;code&gt; 这个类型：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static const&lt;&#x2F;span&gt;&lt;span&gt; BaseTy *
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;getTrailingObjectsImpl&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; BaseTy *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Obj&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                       TrailingObjectsBase::OverloadToken&amp;lt;BaseTy&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; Obj;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;callNumTrailingObjects&lt;&#x2F;code&gt; 则是直接调用到 &lt;code&gt;TopTrailingObj&lt;&#x2F;code&gt; 中的实现了，因为每层类型中并没有增加重载，它的实现如下：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; T&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span&gt;size_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;callNumTrailingObjects&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; BaseTy *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;Obj&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                                       TrailingObjectsBase::OverloadToken&amp;lt;T&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; Obj-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;numTrailingObjects&lt;&#x2F;span&gt;&lt;span&gt;(TrailingObjectsBase::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;OverloadToken&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;());
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这里是用到了 &lt;code&gt;BaseTy&lt;&#x2F;code&gt; 这个参数，在 &lt;code&gt;TargetStructDescriptor&lt;&#x2F;code&gt; 的使用场景中 &lt;code&gt;BaseTy&lt;&#x2F;code&gt; 为 &lt;code&gt;TargetStructDescriptor&amp;lt;Runtime&amp;gt;&lt;&#x2F;code&gt;，而 &lt;code&gt;TargetStructDescriptor&lt;&#x2F;code&gt; 继承自 &lt;code&gt;TrailingObjects&lt;&#x2F;code&gt;，这种手法叫 &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Curiously_recurring_template_pattern&quot;&gt;CRTP&lt;&#x2F;a&gt;，即父类通过模板参数感知子类，从而实现编译期多态。在这个例子中，&lt;code&gt;callNumTrailingObjects&lt;&#x2F;code&gt; 调用到 &lt;code&gt;TargetStructDescriptor&lt;&#x2F;code&gt; 中的 &lt;code&gt;numTrailingObjects&lt;&#x2F;code&gt; 实现，实现不同类型的自定义行为：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;TargetStructDescriptor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  size_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;numTrailingObjects&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(OverloadToken&amp;lt;ForeignMetadataInitialization&amp;gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hasForeignMetadataInitialization&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;() &lt;&#x2F;span&gt;&lt;span&gt;? &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  size_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;numTrailingObjects&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(OverloadToken&amp;lt;SingletonMetadataInitialization&amp;gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hasSingletonMetadataInitialization&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;() &lt;&#x2F;span&gt;&lt;span&gt;? &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  size_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;numTrailingObjects&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(OverloadToken&amp;lt;MetadataListCount&amp;gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hasCanonicicalMetadataPrespecializations&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;() &lt;&#x2F;span&gt;&lt;span&gt;?
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  size_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;numTrailingObjects&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(OverloadToken&amp;lt;MetadataListEntry&amp;gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hasCanonicicalMetadataPrespecializations&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;() &lt;&#x2F;span&gt;&lt;span&gt;?
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;getTrailingObjects&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;MetadataListCount&amp;gt;()-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;count
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;      &lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;yong-fa-fen-xi-xiao-jie&quot;&gt;用法分析 &amp;amp; 小结&lt;&#x2F;h3&gt;
&lt;p&gt;到这里我们就可以分析一下 &lt;code&gt;TrailingObjects&lt;&#x2F;code&gt; 的作用了。首先整个 &lt;code&gt;TrailingObjects&lt;&#x2F;code&gt; 继承链中没有任何存储字段，因此当一个类型继承它是不会更改内存布局。然后来看一下 &lt;code&gt;getTrailingObjects&lt;&#x2F;code&gt; 方法的逻辑，假设对于 &lt;code&gt;TrailingObjects&amp;lt;Base, A, B&amp;gt;&lt;&#x2F;code&gt; 调用 &lt;code&gt;getTrailingObjects&amp;lt;B&amp;gt;()&lt;&#x2F;code&gt;，其调用过程为：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;getTrailingObjects&amp;lt;B&amp;gt;()
&lt;&#x2F;span&gt;&lt;span&gt;= getTrailingObjectsImpl&amp;lt;B&amp;gt;()
&lt;&#x2F;span&gt;&lt;span&gt;= getTrailingObjectsImpl(A) + callNumTrailingObjects(A)
&lt;&#x2F;span&gt;&lt;span&gt;= (A*)(getTrailingObjectsImpl(Base) + callNumTrailingObjects(Base)) + callNumTrailingObjects(A)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以得出 &lt;code&gt;TrailingObjects&lt;&#x2F;code&gt; 作用的结构内存布局为：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;+------+------------+------------+
&lt;&#x2F;span&gt;&lt;span&gt;| Base | A * num(A) | B * num(B) |
&lt;&#x2F;span&gt;&lt;span&gt;+------+------------+------------+
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这与 Swift ABI 约定的 Metadata 在二进制中的布局一致，通过 &lt;code&gt;TrailingObjects&lt;&#x2F;code&gt; 我们可以自由地声明类型的内存映射，在顺序和数量上的调整更加灵活。相比于简单的指针偏移计算，它能够提供更强的类型安全性，并且能够复用大部分计算逻辑，减少代码错误。&lt;&#x2F;p&gt;
&lt;p&gt;当然这种结构也有一些不大不小的缺点，比如会让代码看起来更晦涩，不太容易看出类型的真实结构；另一方面，受制于 C++ 编译器的优化能力，模板 + 非尾递归的代码不能被优化为简单的表达式计算（尽管它在运行时做的确实就是一个简单的表达式计算），在运行效率上可能有一定开销，至少方法调用是真实存在的：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;swift-runtime-trailing-objects&#x2F;5.png&quot; alt=&quot;bt&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h2&gt;
&lt;p&gt;本文通过对 &lt;code&gt;TrailingObjects&lt;&#x2F;code&gt; 的分析，用具体例子介绍了自己在 Swift Runtime 的调试和源码阅读上的思路。相比 Objective-C Runtime，Swift Runtime 在复杂度和抽象程度上会更上一层，不过好在调试相对更容易。&lt;&#x2F;p&gt;
&lt;p&gt;希望本文对大家可以起到抛砖引玉的作用。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;xiang-guan-lian-jie&quot;&gt;相关链接&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;swift.org&#x2F;blog&#x2F;abi-stability-and-more&#x2F;&quot;&gt;ABI Stability and More&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;swift&#x2F;blob&#x2F;e65ae80172ade4120ef51c100e1a69026866936e&#x2F;include&#x2F;swift&#x2F;ABI&#x2F;TrailingObjects.h&quot;&gt;TrailingObjects.h&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;swift&#x2F;blob&#x2F;e65ae80172ade4120ef51c100e1a69026866936e&#x2F;include&#x2F;swift&#x2F;ABI&#x2F;Metadata.h&quot;&gt;Metadata.h&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;en.cppreference.com&#x2F;w&#x2F;cpp&#x2F;language&#x2F;partial_specialization&quot;&gt;Partial template specialization - cppreference.com&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;129329663&quot;&gt;C++ Compiler as a Brainfuck Interpreter&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;58179258&quot;&gt;从源码解析 Swift 弱引用&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>2020 年终总结</title>
		<published>2021-01-31T00:00:00+00:00</published>
		<updated>2021-01-31T00:00:00+00:00</updated>
		<link rel="alternate" href="https://unixzii.github.io/all-about-2020/" type="text/html"/>
		<id>https://unixzii.github.io/all-about-2020/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;2020 对每个人来说都是多变的一年，突如其来的疫情打乱了一切...&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;总算在新年第一个月结束前写完了这个年终总结，拖延症还是没有改掉。这一年发生了许多事情，就按类别纬度分别写一下吧。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;yi-qing&quot;&gt;疫情&lt;&#x2F;h1&gt;
&lt;p&gt;似乎早在回家之前就听说武汉出现了奇怪的肺炎，每天都在增加新的病例。但是当时所有人都大意了，我当时得知这个事情以后也是丝毫没有在意，感觉与我无关。&lt;&#x2F;p&gt;
&lt;p&gt;说巧不巧，回家以后跟所有同学都约过了，就等春节了。&lt;&#x2F;p&gt;
&lt;p&gt;结果，疫情爆发了，全国范围的...&lt;&#x2F;p&gt;
&lt;p&gt;春节之后我们取消了所有的聚会，走亲访友都没有，就老老实实地在家里待着。因为没有口罩，如果不是为了买生活必备品，出门都不会出。所有人都非常恐慌，每天都在关注新闻，各种媒体、社交网络的报道。&lt;&#x2F;p&gt;
&lt;p&gt;不知道从什么时候开始，疫情仿佛忽然得到了控制。外出吃饭、聚会、看电影又恢复了正常，我们的生活也慢慢恢复平静，好像疫情从未发生一样...&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;但有些人有些事，我不会忘记...&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;gong-zuo&quot;&gt;工作&lt;&#x2F;h1&gt;
&lt;p&gt;毕业正好一年，在阿里也呆了一年多的时间，这个时间不长，但对我来说已经足够了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zai-jia-ban-gong&quot;&gt;在家办公&lt;&#x2F;h2&gt;
&lt;p&gt;春节之后，疫情爆发了，几乎所有互联网公司都开始了在家办公。我也不例外，在家呆了大约一个月的时间，3 月 1 号才回到杭州，然后又开始为期两周的居家隔离。&lt;&#x2F;p&gt;
&lt;p&gt;在家办公是种很特别的体验，就是你可以在不影响工作的同时想做什么做什么，跟家里人吃饭、逛街、聊聊天。但是唯一要忍受的就是更长的工作时间，因为在家，没有了上下班时间的限制（钉钉要求所有员工 9:30 必须离开公司，否则罚款），大家的工作和生活更融为一体。早晨一睁眼，直接拿过手机就开始开早会；晚上在床上提交完最后一行代码，合上电脑就能睡觉。有的人能承受，有的人忍不了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;mao-dun-chan-sheng&quot;&gt;矛盾产生&lt;&#x2F;h2&gt;
&lt;p&gt;因为在家办公，生活作息都会影响家人，有的时候一个电话会议能从早上 10 点开到下午 1 点，午饭都来不及吃。家里人觉得这种工作不适合长期做。有的时候需要平衡两方的压力，自己确实也会很烦躁。其他的事情记不清了，只记得那时争吵不断...&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gong-si-wen-hua&quot;&gt;公司文化&lt;&#x2F;h2&gt;
&lt;p&gt;来阿里之前，很多事情没有想清楚：不知道为什么来，不知道下一步该怎么走。可能就觉得，害，阿里牛逼啊。毕业前确实会有这样的学生思维。但是来了以后却发现这里的氛围、文化与我格格不入，我无法说服自己变成他们所谓的“价值观正确”的人。也不是说那种文化不好，没有绝对的好不好，只有自己觉得合不合适。去拼多多的人也不见得全都是要死要活的，看自己怎么选择了。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;我为那些真心喜欢阿里文化的人高兴，为那些不喜欢却被无形力量束缚的人惋惜...&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;kai-shi-mian-shi&quot;&gt;开始面试&lt;&#x2F;h2&gt;
&lt;p&gt;在确定了这里不再适合自己发展下去之后，我开始了各种面试。这期间面过很多公司，也包括微软。因为完全没有准备（尤其是算法方面），还是在微软第 5 面 failed 掉了。也没错，“如果这真是你的 dream company，你总要为此付出点什么”。&lt;&#x2F;p&gt;
&lt;p&gt;非常幸运的是，剩下几个公司的面试都通过了，感谢这些公司的面试官和 HR。&lt;&#x2F;p&gt;
&lt;p&gt;面试的经历其实没什么好讲的，我没有换新的方向，原来在钉钉做 Mac app 开发，现在继续自己的老本行做 iOS。面试嘛，八股文再复习一遍就没问题了。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ji-xiao-chi-zhi&quot;&gt;绩效 &amp;amp; 离职&lt;&#x2F;h2&gt;
&lt;p&gt;再拿到 offer 以后我始终没有跟主管提离职的想法，毕竟绩效还没有出，我不奢望会有多么超出预期的绩效结果，但也不想什么都拿不到地走人。&lt;&#x2F;p&gt;
&lt;p&gt;快 4 月底的时候，绩效终于出了：3.75B。对于这个结果，我其实没有太意外，以 P5 的身份做了很多 P6 应该做的事情，在 BU 整体绩效很好的前提下，给一个 3.75 也不是什么过分的事情。不管是出于什么想法，我感谢那些曾经给予我支持和认可的人。&lt;&#x2F;p&gt;
&lt;p&gt;虽然很无情，我还是跟主管提了离职。中途肯定也经历了各种层级领导的劝说，也有内心的小动摇，但走还是要走的。大概又经历了不到一个月的时间吧，我离开了阿里...&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ru-zhi-xin-gong-si&quot;&gt;入职新公司&lt;&#x2F;h2&gt;
&lt;p&gt;关注过我的朋友应该都知道我离开阿里来了字节，字节对于我来说是一个非常新鲜的地方，用一句话说就是：&amp;quot;It&#x27;s big, yet simple.&amp;quot; 没有那么多令自己不适的文化，同事也都非常年轻。虽然不是完美的，但对我来说尚好。在字节遇到了很多老朋友，不管是同学还是网友，仿佛这个公司让我离圈子更近了，感觉还是很有趣的一件事。&lt;&#x2F;p&gt;
&lt;p&gt;在公司 landing 的时间也比较短，就习惯了这里的工作方式，继续做着一些我擅长的事情。非常有幸在这半年的时间里也收获了一些小惊喜，比如 Spot Bonus，感谢大家的肯定。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;ji-zhu&quot;&gt;技术&lt;&#x2F;h1&gt;
&lt;p&gt;工作方面写得看似很多，但文中的部分也只占了现实的 10% 不到。今年在技术方面感觉没有什么太值得写得东西，扒了扒自己之前写的代码，就简单总结一下吧。&lt;&#x2F;p&gt;
&lt;p&gt;钉钉之前想调研接入 Flutter 的可能性，因为我负责 Mac 端，所以也做了很多尝试：比如熟悉 engine 层，尝试修改 embedder 加入对 Metal surface 的支持，Dart 与 native 通讯如何复用现有 JavaScript Bridge 等等。期间还做了很多衍生的小项目，比如用 Rust 写的 IDL parser &amp;amp; code generator，第一次用 parser combinator 的方式写 parser，感觉写起来还是非常爽快的。&lt;&#x2F;p&gt;
&lt;p&gt;然后也做了一些 SwiftUI 和 Swift 的研究，比如 Preference 机制、SIL、Swift 类型系统实现等等，从之前的不了解到现在的一知半解了吧，哈哈。然后也小小地参与了一把 Swift async 提案的讨论和 code review，希望自己的想法可以有机会被放大。&lt;&#x2F;p&gt;
&lt;p&gt;其他的就是一些所谓的屠龙技了，一些看起来很厉害实则没有任何用的东西，比如第一次学会用 C++ template 写快排...&lt;&#x2F;p&gt;
&lt;h1 id=&quot;dian-zi-chan-pin-ruan-jian&quot;&gt;电子产品 &amp;amp; 软件&lt;&#x2F;h1&gt;
&lt;p&gt;身为果粉，今年算是把所有常用设备都更新了一遍：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Apple Watch Series 6&lt;&#x2F;li&gt;
&lt;li&gt;iPhone 12 mini&lt;&#x2F;li&gt;
&lt;li&gt;Mac mini (Apple Silicon)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;全是今年发布的新产品，iPad 就算了，一方面之前的老款 iPad Pro 一直吃灰，对我来说本来就不是高频使用的产品，另一方面今年 Apple 也没有更新 iPad Pro，明年目测会有更牛逼的新款出现。&lt;&#x2F;p&gt;
&lt;p&gt;我对今年购买的这些产品的感受就是：Leap Forward。尤其是 Mac mini，表现十分亮眼，第一次让我感觉到了 Apple 产品也是有性价比的。iPhone 12 mini 则是用差不多 1&#x2F;3 的价格购买了一个比 iPhone Xs 更好一点的体验。总的来说，这波不亏。&lt;&#x2F;p&gt;
&lt;p&gt;今年购买的软件倒是不多，大部分都是游戏了，比如 Switch 上的《Overcooked 2》，Xbox 上的《Unravel 2》，还有一些 Steam 游戏。然后升级了一下 Surge v4。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;gan-qing&quot;&gt;感情&lt;&#x2F;h1&gt;
&lt;blockquote&gt;
&lt;p&gt;12 月 3 号：我终于跟他在一起了。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;本来我已经对这个充满情侣的世界绝望了，因为我是个低社交爱好者，除了同学和朋友，我不会主动接触任何陌生人。平时用工作和研究技术来填满自己的时间，可能也是一种麻痹吧。&lt;&#x2F;p&gt;
&lt;p&gt;直到遇见他...&lt;&#x2F;p&gt;
&lt;p&gt;从来没有那么在乎一个人，那么想为一个人做些什么。也许每个人内心都有一个属于 ta 的天使，非常巧的是，那个天使就出现在了我的面前。我知道，这条爱情道路上必然会有诸多坎坷，但我也知道，没有任何人可以动摇。Because &lt;strong&gt;love is love&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;今年在一起的时间不长，那个圣诞夜，那个元旦，那些个工作日的夜晚... 那些事情都会留在我们的记忆里，这个故事才刚刚开始，未完待续...&lt;&#x2F;p&gt;
&lt;h1 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h1&gt;
&lt;p&gt;用两个词总结这一年那就是**「Changes &amp;amp; Chances」**，意外的改变创造了新的机遇，而新的机遇又带来新的改变。&lt;&#x2F;p&gt;
&lt;p&gt;2020 年，工作的事情太多。2021 年，希望能投入更多到自己的生活。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>从 SwiftUI 谈声明式 UI 与类型系统</title>
		<published>2019-06-06T00:00:00+00:00</published>
		<updated>2019-06-06T00:00:00+00:00</updated>
		<link rel="alternate" href="https://unixzii.github.io/swiftui-declarative-ui-n-type-system/" type="text/html"/>
		<id>https://unixzii.github.io/swiftui-declarative-ui-n-type-system/</id>
		<content type="html">&lt;h1 id=&quot;hello-swiftui&quot;&gt;Hello, SwiftUI&lt;&#x2F;h1&gt;
&lt;p&gt;Apple 在 WWDC19 上正式发布了 &lt;a href=&quot;https:&#x2F;&#x2F;developer.apple.com&#x2F;ipad-apps-for-mac&#x2F;&quot;&gt;&lt;strong&gt;Project Catalyst&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt;（原 Marzipan），使得开发者能够将 iPadOS app 移植到 macOS 上。同时 &lt;a href=&quot;https:&#x2F;&#x2F;developer.apple.com&#x2F;xcode&#x2F;swiftui&#x2F;&quot;&gt;&lt;strong&gt;SwiftUI&lt;&#x2F;strong&gt;&lt;&#x2F;a&gt; 也压轴亮相，正式统一了 Apple 全平台的 UI 开发解决方案。恰逢前些时候，Google 在其 I&#x2F;O 大会上亮相了 Jetpack Compose —— 一个全新的 Android 原生 UI 开发框架，标志着两大移动操作系统阵营全面拥抱声明式 UI 开发模式。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;sheng-ming-shi-ui-de-qian-shi-jin-sheng&quot;&gt;声明式 UI 的前世今生&lt;&#x2F;h1&gt;
&lt;p&gt;其实声明式 UI 并不是什么新技术，早在 2006 年，微软就已经发布了其新一代界面开发框架 &lt;strong&gt;WPF&lt;&#x2F;strong&gt;，其采用了 XAML 标记语言，支持双向数据绑定、可复用模板等特性。&lt;&#x2F;p&gt;
&lt;p&gt;2010 年，由诺基亚领导的 Qt 团队也正式发布了其下一代界面解决方案 &lt;strong&gt;Qt Quick&lt;&#x2F;strong&gt;，同样也是声明式，甚至 Qt Quick 起初的名字就是 Qt Declarative。QML 语言同样支持数据绑定、模块化等特性，此外还支持内置 JavaScript，开发者只用 QML 就可以开发出简单的带交互的原型应用。&lt;&#x2F;p&gt;
&lt;p&gt;声明式 UI 框架近年来飞速发展，并且被 Web 开发带向高潮。&lt;strong&gt;React&lt;&#x2F;strong&gt; 更是为声明式 UI 奠定了坚实基础并一直引领其未来的发展。随后 &lt;strong&gt;Flutter&lt;&#x2F;strong&gt; 的发布也将声明式 UI 的思想成功带到移动端开发领域...&lt;&#x2F;p&gt;
&lt;h1 id=&quot;sheng-ming-shi-dao-di-shi-shi-yao&quot;&gt;声明式到底是什么&lt;&#x2F;h1&gt;
&lt;p&gt;想象我们要实现下面这个界面：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;1.jpg&quot; alt=&quot;SwiftUI Previews&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;打开开关就让下面的 label 显示 on，反之显示 off。如果我们要用非声明式的方式实现，即命令式，那么需要：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;1. 创建一个 `UISwitch`，设置它的 change 事件 handler
&lt;&#x2F;span&gt;&lt;span&gt;2. 创建一个 `UILabel`
&lt;&#x2F;span&gt;&lt;span&gt;3. 创建一个 `UIStackView`，设置方向为垂直
&lt;&#x2F;span&gt;&lt;span&gt;4. 将 1、2 创建的两个视图添加到 `UIStackView` 中
&lt;&#x2F;span&gt;&lt;span&gt;5. change 事件触发时读取开关的当前状态，设置相应字符串到 label 中
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这样做面对一个状态，我们尚且能够正确处理，但随着应用日渐复杂，状态也越来越多并且错综复杂，状态变化的顺序甚至也能影响应用逻辑的正确性，因为我们对每个事件的处理都是对界面的增量修改。一旦前一个状态有错误，后面就会错上加错，接下来多线程混入，然后 boom，你的应用可能就 crash 了。&lt;&#x2F;p&gt;
&lt;p&gt;声明式的意思就是让我们描述我们需要一个什么样的界面，而不是告诉计算机一步一步干什么。那么上面的例子用声明式就是这样：&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“我需要一个界面，它是一个 VStack（垂直布局），里面有一个开关，开关的值与 switchValue 的布尔值绑定，VStack 里接下来是一个 Text，它的值当 switchValue 为 true 时是 foo，否则是 bar”&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;我们可以发现，全文没有命令，都是在描述界面是怎样的。&lt;code&gt;switchValue&lt;&#x2F;code&gt; 我们称之为 “The Source of Truth”，Toggle 的状态、Text 的文本内容都与它相绑定。状态变化时，界面按照先前描述的重新“渲染”即可得到状态绝对正确的界面。这正是声明式的优势所在，&lt;strong&gt;降低状态增加时界面维护的复杂度&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;swiftui-yu-qi-ta-kuang-jia-de-yi-tong&quot;&gt;SwiftUI 与其他框架的异同&lt;&#x2F;h1&gt;
&lt;p&gt;SwiftUI 自亮相以来，全网就在讨论其与 React、Flutter 之间的关系云云。经过这两天的研究，我想简单谈谈我的观点：&lt;em&gt;（免责声明：没有看过源码，也没有参与现场 Lab，一切都是个人想法）&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;首先是与 Flutter 的对比，Flutter 的思路是从 0 开始，即语言、基础库、渲染引擎、排版引擎即框架本身全部由自己实现，其渲染引擎 Skia 只需要操作系统为止提供一个 GL Context 便可以完成所有图形渲染，这使得其跨平台性变得十分强大，到目前为止 Windows、Linux、macOS、Fuchsia 都已经得到了 Flutter 官方的支持。&lt;&#x2F;p&gt;
&lt;p&gt;这种做法我认为有利有弊，首先好处是所有平台下行为一致，不管是滚动视图、Material Design 控件还是模糊效果这些在其他平台没有的都得到了全平台的支持，开发者并不需要为这些去做平台间的适配，反观 React Native... 当然缺点也是存在的，Flutter 这种做法类似于游戏引擎，平台提供的 UI 特性它一概不用，因此 Flutter View 与原生视图的交互就没有那么容易了，同时新的 Dart 语言貌似也不是非常受社区和开发者喜爱。&lt;&#x2F;p&gt;
&lt;p&gt;SwiftUI 没有像 Flutter 那样从头再来，这个全新的框架依旧使用了 UIKit、AppKit 等作为基础。但它并不是一个 UIKit 的声明式封装，通过 Xcode 的调试视图可以看出这一点：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;images&#x2F;2.jpg&quot; alt=&quot;Xcode View Debugger&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;许多基础组件，像 Text、Button 等都并不是直接使用 &lt;code&gt;UILabel&lt;&#x2F;code&gt;、&lt;code&gt;UIButton&lt;&#x2F;code&gt; 而是一个名为 &lt;code&gt;DisplayList.ViewUpdater.Platform.CGDrawingView&lt;&#x2F;code&gt; 的 &lt;code&gt;UIView&lt;&#x2F;code&gt; 子类。它们使用了自定义绘制，但又承载于 UIKit 的环境中，因此我猜测 SwiftUI 只提供了组件的自定义渲染和布局引擎，它使用到的底层技术还是 Core Animation、Core Graphics、Core Text 等。使用自定义绘制去实现组件可以理解成为跨平台提供便利，毕竟一个按钮还要区分 &lt;code&gt;UIButton&lt;&#x2F;code&gt;、&lt;code&gt;NSButton&lt;&#x2F;code&gt; 来实现未免有些麻烦。但是部分复杂的控件还是采用了 UIKit 中已有的类，比如 &lt;code&gt;UISwitch&lt;&#x2F;code&gt; 等。由于未脱离 UIKit 体系，嵌入一个 UIView 非常容易，你不需要搞什么外部纹理（Flutter 需要），因为它们的上下文是同一个，坐标系也是同一个。&lt;&#x2F;p&gt;
&lt;p&gt;所以我认为 SwiftUI 更加类似 React Native，使用系统框架提供的组件，只不过绘制和布局可以自己来实现，这在 SwiftUI 之前也有相关的框架这样实践的，比如 &lt;strong&gt;Yoga&lt;&#x2F;strong&gt;、&lt;strong&gt;ComponentKit&lt;&#x2F;strong&gt; 等。&lt;&#x2F;p&gt;
&lt;h1 id=&quot;swiftui-de-lei-xing-xi-tong&quot;&gt;SwiftUI 的类型系统&lt;&#x2F;h1&gt;
&lt;p&gt;Flutter、React 的类型系统并不是强约束，一个界面里有一个 Text 和有两个 Text 类型是一样的，React 使用 JavaScript 更是无类型。SwiftUI 与它们不同，它使用了强类型约束。举个例子：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;swift&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-swift &quot;&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span&gt;VStack {
&lt;&#x2F;span&gt;&lt;span&gt;  Text(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;Hello&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;与&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;swift&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-swift &quot;&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span&gt;VStack {
&lt;&#x2F;span&gt;&lt;span&gt;  Text(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;Hello&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;  Text(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;World&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;与&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;swift&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-swift &quot;&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span&gt;VStack {
&lt;&#x2F;span&gt;&lt;span&gt;  Text(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;Hello&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;      .color(Color.red)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;类型都是不同的。首先上面这种语法叫做 &lt;strong&gt;Function Builders&lt;&#x2F;strong&gt;，是 Apple “私自”夹带到 Swift 里的私货。上面这些表达式最后都会得到一个实现了 &lt;code&gt;View&lt;&#x2F;code&gt; 协议的&lt;strong&gt;具体类型&lt;&#x2F;strong&gt;，SwiftUI 里基本使用的都是&lt;strong&gt;具体类型&lt;&#x2F;strong&gt;，而不是&lt;strong&gt;协议类型&lt;&#x2F;strong&gt;，首先 &lt;code&gt;VStack&lt;&#x2F;code&gt; 是一个 struct 同时也是一个具体类型，它的构造方法里接受一个闭包，这个闭包使用了通过 &lt;code&gt;@functionBuilder&lt;&#x2F;code&gt; 修饰的 &lt;code&gt;ViewBuilder&lt;&#x2F;code&gt; 结构体作为 builder，因此上面的第二段代码在编译时会被转化成：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;swift&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-swift &quot;&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span&gt;VStack {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; v1 = ViewBuilder.buildExpression(Text(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;Hello&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; v2 = ViewBuilder.buildExpression(Text(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;World&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; ViewBuilder.buildBlock(v1, v2)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;然后我们看一下上面这个 &lt;code&gt;ViewBuilder.buildBlock&lt;&#x2F;code&gt; 重载的签名：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;static func buildBlock&amp;lt;C0, C1&amp;gt;(_ c0: C0, _ c1: C1) -&amp;gt; TupleView&amp;lt;(C0, C1)&amp;gt; where C0 : View, C1 : View
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;所以一个 Text 和两个 Text，它们的父容器 VStack 的类型都是不同的！另外提一下，&lt;code&gt;buildBlock&lt;&#x2F;code&gt; 的范型参数最多有 10 个：&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;user-gold-cdn.xitu.io&#x2F;2019&#x2F;6&#x2F;6&#x2F;16b2bc2dc598431a?w=1624&amp;amp;h=1134&amp;amp;f=png&amp;amp;s=277677&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;划重点：也就是你的一个视图层级（目前）不能有超过 10 个子视图。&lt;&#x2F;strong&gt; 且超过后编译器的错误提示丝毫不会体现这一点，了解这个将会非常节约你的时间！&lt;&#x2F;p&gt;
&lt;p&gt;不同的状态对应的视图也不同，但是它们的类型是相同的，这意味着什么呢？那就是，&lt;strong&gt;不需要 Diff-Patch 了&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;我们想象下面的场景：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;swift&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-swift &quot;&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span&gt;VStack {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; something {
&lt;&#x2F;span&gt;&lt;span&gt;      Text(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;something is true&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;  Text(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;something else&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;!something {
&lt;&#x2F;span&gt;&lt;span&gt;      Text(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;&amp;quot;something is not true&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;当 &lt;code&gt;something&lt;&#x2F;code&gt; 变化时，视图应该怎么变化？对于 React、Flutter 来说，它们没有类型的概念，每次只能拿到两个快照（一个当前状态的，一个新状态的）。它们有两个选择去完成界面的更新：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;1. 把老的视图全部移除，重新添加新视图
&lt;&#x2F;span&gt;&lt;span&gt;2. 找出它们的差异，根据差异去修改视图
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;第一种方法最简单，但是性能很差，且不能保存视图自身的状态。第二种方法需要高效的算法加持，看起来能解决我们的问题，但是&lt;strong&gt;它不是必要的&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;SwiftUI 的做法是根据类型来更新界面，上面这段代码的类型是：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;swift&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-swift &quot;&gt;&lt;code class=&quot;language-swift&quot; data-lang=&quot;swift&quot;&gt;&lt;span&gt;VStack&amp;lt;TupleView&amp;lt;Text?, Text, Text?&amp;gt;&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;有了类型框架就能做静态优化，这类似前端框架 Svelte 和 Vue.js 3.0 所做的一些优化，可以称之为 AOT。&lt;&#x2F;p&gt;
&lt;p&gt;在没有类型的情况下，每次状态变化，界面中都只有两个 Text，只不过内容不一样，这时候框架通过 diff 认为界面中的 Text 控件本身没变，只是内容变了，于是给它们设置了新的内容。&lt;&#x2F;p&gt;
&lt;p&gt;但事实并不是这样，&lt;code&gt;something&lt;&#x2F;code&gt; 变化时，界面显示的 Text 是不同的，中间的 Text 始终显示 “something else”，变化的是它上下两个相邻的 Text。框架拿到新视图时就可以按范型参数的顺序去检查他们的差异：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;Before update:
&lt;&#x2F;span&gt;&lt;span&gt;VStack(TupleView(Text(...), Text(...), nil))
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;After update:
&lt;&#x2F;span&gt;&lt;span&gt;VStack(TupleView(nil, Text(...), Text(...)))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;它们的相对位置写在了类型中，这样就能避免中间的视图被修改，没有类型信息或其他元信息，这点是绝对做不到的。&lt;&#x2F;p&gt;
&lt;p&gt;SwiftUI 对于类型做得其实更多，所有的字体调整、位置调整等操作在 SwiftUI 中都是通过 &lt;code&gt;ViewModifier&lt;&#x2F;code&gt; 实现的，调整后的视图类型为 &lt;code&gt;View.Modified&amp;lt;some ViewModifier&amp;gt;&lt;&#x2F;code&gt;，因此有无这些参数调整的视图，类型也是不同的，这些都将有助于框架去做一些静态优化。&lt;&#x2F;p&gt;
&lt;p&gt;关于 SwiftUI 的详细使用方面，我之后可能还会再更新文章，本文就是简单谈谈我对框架宏观层面的理解。祝大家 WWDC 周玩得开心～&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;References:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;forums.swift.org&#x2F;t&#x2F;pitch-function-builders&#x2F;25167&quot;&gt;Function builders - Swift Forums&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;swift-evolution&#x2F;blob&#x2F;9992cf3c11c2d5e0ea20bee98657d93902d5b174&#x2F;proposals&#x2F;XXXX-function-builders.md&quot;&gt;Function builders (draft proposal)&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;swift-evolution&#x2F;blob&#x2F;master&#x2F;proposals&#x2F;0244-opaque-result-types.md&quot;&gt;Opaque Result Types&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;forums.swift.org&#x2F;t&#x2F;important-evolution-discussion-of-the-new-dsl-feature-behind-swiftui&#x2F;25168&quot;&gt;Evolution discussion of the new DSL feature behind SwiftUI&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;developer.apple.com&#x2F;wwdc19&#x2F;402&quot;&gt;WWDC 19 - 402&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;svelte.dev&#x2F;&quot;&gt;https:&#x2F;&#x2F;svelte.dev&#x2F;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;unixzii&#x2F;status&#x2F;1136330564582092800?s=20&quot;&gt;https:&#x2F;&#x2F;twitter.com&#x2F;unixzii&#x2F;status&#x2F;1136330564582092800?s=20&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>从源码解析 Swift 弱引用</title>
		<published>2019-03-03T00:00:00+00:00</published>
		<updated>2019-03-03T00:00:00+00:00</updated>
		<link rel="alternate" href="https://unixzii.github.io/swift-weak-reference/" type="text/html"/>
		<id>https://unixzii.github.io/swift-weak-reference/</id>
		<content type="html">&lt;blockquote&gt;
&lt;p&gt;序言：各个社区有关 Objective-C weak 机制的实现分析文章有很多，然而 Swift 发布这么长时间以来，有关 ABI 的分析文章一直非常少，似乎也是很多 iOS 开发者未涉及的领域… 本文就从源码层面分析一下 Swift 是如何实现 weak 机制的。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;zhun-bei-gong-zuo&quot;&gt;准备工作&lt;&#x2F;h2&gt;
&lt;p&gt;由于 Swift 源码量较大，强烈建议大家把 repo clone 下来，结合源码一起来看这篇文章。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;color:#c0c5ce;&quot;&gt;&lt;code&gt;&lt;span&gt;$ git clone https:&#x2F;&#x2F;github.com&#x2F;apple&#x2F;swift.git
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Swift 整个工程采用了 CMake 作为构建工具，如果你想用 Xcode 来打开的话需要先安装 LLVM，然后用 &lt;code&gt;cmake -G&lt;&#x2F;code&gt; 生成 Xcode 项目。&lt;&#x2F;p&gt;
&lt;p&gt;我们这里只是进行源码分析，我就直接用 &lt;strong&gt;Visual Studio Code&lt;&#x2F;strong&gt; 配合 &lt;strong&gt;C&#x2F;C++&lt;&#x2F;strong&gt; 插件了，同样支持符号跳转、查找引用。另外提醒一下大家，Swift stdlib 里 C++ 代码的类型层次比较复杂，不使用 IDE 辅助阅读起来会相当费劲。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zheng-wen&quot;&gt;正文&lt;&#x2F;h2&gt;
&lt;p&gt;下面我们就正式进入源码分析阶段，首先我们来看一下 Swift 中的对象（&lt;code&gt;class&lt;&#x2F;code&gt; 实例）它的内存布局是怎样的。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;heapobject&quot;&gt;&lt;code&gt;HeapObject&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;我们知道 Objective-C 在 runtime 中通过 &lt;code&gt;objc_object&lt;&#x2F;code&gt; 来表示一个对象，这些类型定义了对象在内存中头部的结构。同样的，在 Swift 中也有类似的结构，那就是 &lt;code&gt;HeapObject&lt;&#x2F;code&gt;，我们来看一下它的定义：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;HeapObject {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;&#x2F; This is always a valid pointer to a metadata object.
&lt;&#x2F;span&gt;&lt;span&gt;  HeapMetadata &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;*metadata;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;HeapObject&lt;&#x2F;span&gt;&lt;span&gt;() = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;default&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Initialize a HeapObject header as appropriate for a newly-allocated object.
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;constexpr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;HeapObject&lt;&#x2F;span&gt;&lt;span&gt;(HeapMetadata &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;newMetadata&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;(newMetadata)
&lt;&#x2F;span&gt;&lt;span&gt;    , &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;refCounts&lt;&#x2F;span&gt;&lt;span&gt;(InlineRefCounts::Initialized)
&lt;&#x2F;span&gt;&lt;span&gt;  { }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Initialize a HeapObject header for an immortal object
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;constexpr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;HeapObject&lt;&#x2F;span&gt;&lt;span&gt;(HeapMetadata &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;newMetadata&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                       InlineRefCounts::Immortal_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;immortal&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;  : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;(newMetadata)
&lt;&#x2F;span&gt;&lt;span&gt;  , &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;refCounts&lt;&#x2F;span&gt;&lt;span&gt;(InlineRefCounts::Immortal)
&lt;&#x2F;span&gt;&lt;span&gt;  { }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以看到，&lt;code&gt;HeapObject&lt;&#x2F;code&gt; 的第一个字段是一个 &lt;code&gt;HeapMetadata&lt;&#x2F;code&gt; 对象，这个对象有着与 &lt;code&gt;isa_t&lt;&#x2F;code&gt; 类似的作用，就是用来描述对象类型的（等价于 &lt;code&gt;type(of:)&lt;&#x2F;code&gt; 取得的结果），只不过 Swift 在很多情况下并不会用到它，比如静态方法派发等等。&lt;&#x2F;p&gt;
&lt;p&gt;接下来是 &lt;code&gt;SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS&lt;&#x2F;code&gt;，这是一个宏定义，展开后即：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span&gt;RefCounts&amp;lt;InlineRefCountBits&amp;gt; refCounts;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这是一个相当重要东西，引用计数、弱引用、unowned 引用都与它有关，同时它也是 Swift 对象（文中后续的 Swift 对象均指引用类型，即 &lt;code&gt;class&lt;&#x2F;code&gt; 的实例）中较为复杂的一个结构。&lt;&#x2F;p&gt;
&lt;p&gt;其实说复杂也并不是很复杂，我们知道 Objective-C runtime 里就有很多 &lt;strong&gt;union&lt;&#x2F;strong&gt; 结构的应用，例如 &lt;code&gt;isa_t&lt;&#x2F;code&gt; 有 &lt;strong&gt;pointer&lt;&#x2F;strong&gt; 类型也有 &lt;strong&gt;nonpointer&lt;&#x2F;strong&gt; 类型，它们都占用了相同的内存空间，这样做的好处就是能更高效地使用内存，尤其是这些大量使用到的东西，可以大大减少运行期的开销。类似的技术在 JVM 里也有，就如对象头的 mark word。当然，Swift ABI 中也大量采用这种技术。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;refcounts-lei-xing-he-side-table&quot;&gt;&lt;code&gt;RefCounts&lt;&#x2F;code&gt; 类型和 Side Table&lt;&#x2F;h3&gt;
&lt;p&gt;上面说到 &lt;code&gt;RefCounts&lt;&#x2F;code&gt; 类型，这里我们就来看看它到底是个什么东西。&lt;&#x2F;p&gt;
&lt;p&gt;先看一下定义：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; RefCountBits&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;RefCounts &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  std::atomic&amp;lt;RefCountBits&amp;gt; refCounts;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这就是 &lt;code&gt;RefCounts&lt;&#x2F;code&gt; 的内存布局，我这里省略了所有的方法和类型定义。你可以把 &lt;code&gt;RefCounts&lt;&#x2F;code&gt; 想象成一个线程安全的 wrapper，模板参数 &lt;code&gt;RefCountBits&lt;&#x2F;code&gt; 指定了真实的内部类型，在 Swift ABI 里总共有两种：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typedef&lt;&#x2F;span&gt;&lt;span&gt; RefCounts&amp;lt;InlineRefCountBits&amp;gt; InlineRefCounts;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typedef&lt;&#x2F;span&gt;&lt;span&gt; RefCounts&amp;lt;SideTableRefCountBits&amp;gt; SideTableRefCounts;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;前者是用在 &lt;code&gt;HeapObject&lt;&#x2F;code&gt; 中的，而后者是用在 &lt;code&gt;HeapObjectSideTableEntry&lt;&#x2F;code&gt;（Side Table）中的，这两种类型后文我会一一讲到。&lt;&#x2F;p&gt;
&lt;p&gt;一般来讲，Swift 对象并不会用到 Side Table，一旦对象被 weak 或 unowned 引用，该对象就会分配一个 Side Table。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;inlinerefcountbits&quot;&gt;InlineRefCountBits&lt;&#x2F;h4&gt;
&lt;p&gt;定义：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typedef&lt;&#x2F;span&gt;&lt;span&gt; RefCountBitsT&amp;lt;RefCountIsInline&amp;gt; InlineRefCountBits;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;RefCountInlinedness refcountIsInline&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;RefCountBitsT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;friend class&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; RefCountBitsT&amp;lt;RefCountIsInline&amp;gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;friend class&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; RefCountBitsT&amp;lt;RefCountNotInline&amp;gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static const&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; RefCountInlinedness Inlinedness &lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; refcountIsInline;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typedef typename&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; RefCountBitsInt&amp;lt;refcountIsInline, &lt;&#x2F;span&gt;&lt;span&gt;sizeof&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;)&amp;gt;::Type
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    BitsType;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typedef typename&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; RefCountBitsInt&amp;lt;refcountIsInline, &lt;&#x2F;span&gt;&lt;span&gt;sizeof&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void&lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;)&amp;gt;::SignedType
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    SignedBitsType;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typedef&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt; RefCountBitOffsets&amp;lt;&lt;&#x2F;span&gt;&lt;span&gt;sizeof&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(BitsType)&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    Offsets;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  BitsType bits;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;通过模板替换之后，&lt;code&gt;InlineRefCountBits&lt;&#x2F;code&gt; 实际上就是一个 &lt;code&gt;uint64_t&lt;&#x2F;code&gt;，相关的一堆类型就是为了通过模板元编程让代码可读性更高（或者更低，哈哈哈）。&lt;&#x2F;p&gt;
&lt;p&gt;下面我们来模拟一下对象引用计数 +1：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;调用 SIL 接口 &lt;code&gt;swift::swift_retain&lt;&#x2F;code&gt;：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span&gt;HeapObject *swift::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;swift_retain&lt;&#x2F;span&gt;&lt;span&gt;(HeapObject *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;object&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;_swift_retain&lt;&#x2F;span&gt;&lt;span&gt;(object);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static&lt;&#x2F;span&gt;&lt;span&gt; HeapObject *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;_swift_retain_&lt;&#x2F;span&gt;&lt;span&gt;(HeapObject *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;object&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;SWIFT_RT_TRACK_INVOCATION&lt;&#x2F;span&gt;&lt;span&gt;(object, swift_retain);
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;isValidPointerForNativeRetain&lt;&#x2F;span&gt;&lt;span&gt;(object))
&lt;&#x2F;span&gt;&lt;span&gt;    object-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;refCounts&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;increment&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; object;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; swift::_swift_retain = _swift_retain_;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;调用 &lt;code&gt;RefCounts&lt;&#x2F;code&gt; 的 &lt;code&gt;increment&lt;&#x2F;code&gt; 方法：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;increment&lt;&#x2F;span&gt;&lt;span&gt;(uint32_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;inc &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 3. 原子地读出 InlineRefCountBits 对象（即一个 uint64_t）。
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; oldbits = refCounts.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;load&lt;&#x2F;span&gt;&lt;span&gt;(SWIFT_MEMORY_ORDER_CONSUME);
&lt;&#x2F;span&gt;&lt;span&gt;  RefCountBits newbits;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    newbits = oldbits;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 4. 调用 InlineRefCountBits 的 incrementStrongExtraRefCount 方法
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F;    对这个 uint64_t 进行一系列运算。
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt; fast = newbits.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;incrementStrongExtraRefCount&lt;&#x2F;span&gt;&lt;span&gt;(inc);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 无 weak、unowned 引用时一般不会进入。
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;SWIFT_UNLIKELY&lt;&#x2F;span&gt;&lt;span&gt;(!fast)) {
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(oldbits.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;isImmortal&lt;&#x2F;span&gt;&lt;span&gt;())
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;incrementSlow&lt;&#x2F;span&gt;&lt;span&gt;(oldbits, inc);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 5. 通过 CAS 将运算后的 uint64_t 设置回去。
&lt;&#x2F;span&gt;&lt;span&gt;  } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span&gt;(!refCounts.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;compare_exchange_weak&lt;&#x2F;span&gt;&lt;span&gt;(oldbits, newbits,
&lt;&#x2F;span&gt;&lt;span&gt;                                            std::memory_order_relaxed));
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;到这里就完成了一次 retain 操作。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;sidetablerefcountbits&quot;&gt;SideTableRefCountBits&lt;&#x2F;h4&gt;
&lt;p&gt;上面是不存在 weak、unowned 引用的情况，现在我们来看看增加一个 weak 引用会怎样。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;调用 SIL 接口 &lt;code&gt;swift::swift_weakAssign&lt;&#x2F;code&gt;（暂时省略这块的逻辑，它属于引用者的逻辑，我们现在先分析被引用者）&lt;&#x2F;li&gt;
&lt;li&gt;调用 &lt;code&gt;RefCounts&amp;lt;InlineRefCountBits&amp;gt;::formWeakReference&lt;&#x2F;code&gt; 增加一个弱引用：&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;HeapObjectSideTableEntry* RefCounts&amp;lt;InlineRefCountBits&amp;gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;formWeakReference&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 分配一个 Side Table。
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; side = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;allocateSideTable&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(side)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 增加一个弱引用。
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; side-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;incrementWeak&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;nullptr&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;重点来看一下 &lt;code&gt;allocateSideTable&lt;&#x2F;code&gt; 的实现：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;HeapObjectSideTableEntry* RefCounts&amp;lt;InlineRefCountBits&amp;gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;allocateSideTable&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;failIfDeiniting&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; oldbits = refCounts.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;load&lt;&#x2F;span&gt;&lt;span&gt;(SWIFT_MEMORY_ORDER_CONSUME);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 已有 Side Table 或正在析构就直接返回。
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(oldbits.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hasSideTable&lt;&#x2F;span&gt;&lt;span&gt;()) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; oldbits.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;getSideTable&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else if &lt;&#x2F;span&gt;&lt;span&gt;(failIfDeiniting &amp;amp;&amp;amp; oldbits.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;getIsDeiniting&lt;&#x2F;span&gt;&lt;span&gt;()) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;nullptr&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 分配 Side Table 对象。
&lt;&#x2F;span&gt;&lt;span&gt;  HeapObjectSideTableEntry *side = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;new &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;HeapObjectSideTableEntry&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;getHeapObject&lt;&#x2F;span&gt;&lt;span&gt;());
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; newbits = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;InlineRefCountBits&lt;&#x2F;span&gt;&lt;span&gt;(side);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(oldbits.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hasSideTable&lt;&#x2F;span&gt;&lt;span&gt;()) {
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 此时可能其他线程创建了 Side Table，删除该线程分配的，然后返回。
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; result = oldbits.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;getSideTable&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;delete&lt;&#x2F;span&gt;&lt;span&gt; side;
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; result;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else if &lt;&#x2F;span&gt;&lt;span&gt;(failIfDeiniting &amp;amp;&amp;amp; oldbits.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;getIsDeiniting&lt;&#x2F;span&gt;&lt;span&gt;()) {
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;nullptr&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 用当前的 InlineRefCountBits 初始化 Side Table。
&lt;&#x2F;span&gt;&lt;span&gt;    side-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;initRefCounts&lt;&#x2F;span&gt;&lt;span&gt;(oldbits);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 进行 CAS。
&lt;&#x2F;span&gt;&lt;span&gt;  } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span&gt;(! refCounts.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;compare_exchange_weak&lt;&#x2F;span&gt;&lt;span&gt;(oldbits, newbits,
&lt;&#x2F;span&gt;&lt;span&gt;                                             std::memory_order_release,
&lt;&#x2F;span&gt;&lt;span&gt;                                             std::memory_order_relaxed));
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; side;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;还记得 &lt;code&gt;HeapObject&lt;&#x2F;code&gt; 里的 &lt;code&gt;RefCounts&lt;&#x2F;code&gt; 实际上是 &lt;code&gt;InlineRefCountBits&lt;&#x2F;code&gt; 的一个 wrapper 吗？上面构造完 Side Table 以后，对象中的 &lt;code&gt;InlineRefCountBits&lt;&#x2F;code&gt; 就不是原来的引用计数了，而是一个指向 Side Table 的指针，然而由于它们实际都是 &lt;code&gt;uint64_t&lt;&#x2F;code&gt;，因此需要一个方法来区分。区分的方法我们可以来看 &lt;code&gt;InlineRefCountBits&lt;&#x2F;code&gt; 的构造函数：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span&gt;LLVM_ATTRIBUTE_ALWAYS_INLINE
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;RefCountBitsT&lt;&#x2F;span&gt;&lt;span&gt;(HeapObjectSideTableEntry* side)
&lt;&#x2F;span&gt;&lt;span&gt;    : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;((reinterpret_cast&amp;lt;BitsType&amp;gt;(side) &amp;gt;&amp;gt; Offsets::SideTableUnusedLowBits)
&lt;&#x2F;span&gt;&lt;span&gt;           | (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;BitsType&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &amp;lt;&amp;lt; Offsets::UseSlowRCShift)
&lt;&#x2F;span&gt;&lt;span&gt;           | (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;BitsType&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &amp;lt;&amp;lt; Offsets::SideTableMarkShift))
&lt;&#x2F;span&gt;&lt;span&gt;  {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span&gt;(refcountIsInline);
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其实还是最常见的方法，把指针地址无用的位替换成标识位。&lt;&#x2F;p&gt;
&lt;p&gt;顺便，看一下 Side Table 的结构：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;HeapObjectSideTableEntry &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; FIXME: does object need to be atomic?
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  std::atomic&amp;lt;HeapObject&lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;gt; object;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  SideTableRefCounts refCounts;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;public&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;:
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;HeapObjectSideTableEntry&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(HeapObject &lt;&#x2F;span&gt;&lt;span&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;newObject&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;    : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;object&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;(newObject), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;refCounts&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;()
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  { }
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;此时再增加引用计数会怎样呢？来看下之前的 &lt;code&gt;RefCounts::increment&lt;&#x2F;code&gt; 方法：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;increment&lt;&#x2F;span&gt;&lt;span&gt;(uint32_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;inc &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; oldbits = refCounts.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;load&lt;&#x2F;span&gt;&lt;span&gt;(SWIFT_MEMORY_ORDER_CONSUME);
&lt;&#x2F;span&gt;&lt;span&gt;  RefCountBits newbits;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;do &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    newbits = oldbits;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt; fast = newbits.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;incrementStrongExtraRefCount&lt;&#x2F;span&gt;&lt;span&gt;(inc);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ---&amp;gt; 这次进入这个分支。
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;SWIFT_UNLIKELY&lt;&#x2F;span&gt;&lt;span&gt;(!fast)) {
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(oldbits.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;isImmortal&lt;&#x2F;span&gt;&lt;span&gt;())
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;incrementSlow&lt;&#x2F;span&gt;&lt;span&gt;(oldbits, inc);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;  } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span&gt;(!refCounts.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;compare_exchange_weak&lt;&#x2F;span&gt;&lt;span&gt;(oldbits, newbits,
&lt;&#x2F;span&gt;&lt;span&gt;                                            std::memory_order_relaxed));
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;template &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;typename&lt;&#x2F;span&gt;&lt;span&gt; RefCountBits&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span&gt;RefCounts&amp;lt;RefCountBits&amp;gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;incrementSlow&lt;&#x2F;span&gt;&lt;span&gt;(RefCountBits &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;oldbits&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;                                            uint32_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(oldbits.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;isImmortal&lt;&#x2F;span&gt;&lt;span&gt;()) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else if &lt;&#x2F;span&gt;&lt;span&gt;(oldbits.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;hasSideTable&lt;&#x2F;span&gt;&lt;span&gt;()) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; side = oldbits.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;getSideTable&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ---&amp;gt; 然后调用到这里。
&lt;&#x2F;span&gt;&lt;span&gt;    side-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;incrementStrong&lt;&#x2F;span&gt;&lt;span&gt;(n);
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    swift::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;swift_abortRetainOverflow&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span&gt;HeapObjectSideTableEntry::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;incrementStrong&lt;&#x2F;span&gt;&lt;span&gt;(uint32_t &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;inc&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 最终到这里，refCounts 是一个 RefCounts&amp;lt;SideTableRefCountBits&amp;gt; 对象。
&lt;&#x2F;span&gt;&lt;span&gt;  refCounts.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;increment&lt;&#x2F;span&gt;&lt;span&gt;(inc);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;到这里我们就需要引出 &lt;code&gt;SideTableRefCountBits&lt;&#x2F;code&gt; 了，它与前面的 &lt;code&gt;InlineRefCountBits&lt;&#x2F;code&gt; 很像，只不过又多了一个字段，看一下定义：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ebcb8b;&quot;&gt;SideTableRefCountBits &lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;public &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;RefCountBitsT&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;&amp;lt;RefCountNotInline&amp;gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;{
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  uint32_t weakBits;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#eff1f5;&quot;&gt;}&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;xiao-jie-yi-xia&quot;&gt;小结一下&lt;&#x2F;h4&gt;
&lt;p&gt;不知道上面的内容大家看晕了没有，反正我一开始分析的时候费了点时间。&lt;&#x2F;p&gt;
&lt;p&gt;上面我们讲了两种 &lt;code&gt;RefCounts&lt;&#x2F;code&gt;，一种是 inline 的，用在 &lt;code&gt;HeapObject&lt;&#x2F;code&gt; 中，它其实是一个 &lt;code&gt;uint64_t&lt;&#x2F;code&gt;，可以当引用计数也可以当 Side Table 的指针。&lt;&#x2F;p&gt;
&lt;p&gt;Side Table 是一种类名为 &lt;code&gt;HeapObjectSideTableEntry&lt;&#x2F;code&gt; 的结构，里面也有 &lt;code&gt;RefCounts&lt;&#x2F;code&gt; 成员，是内部是 &lt;code&gt;SideTableRefCountBits&lt;&#x2F;code&gt;，其实就是原来的 &lt;code&gt;uint64_t&lt;&#x2F;code&gt; 加上一个存储弱引用数的 &lt;code&gt;uint32_t&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;weakreference&quot;&gt;&lt;code&gt;WeakReference&lt;&#x2F;code&gt;&lt;&#x2F;h3&gt;
&lt;p&gt;上面说的都是被引用的对象所涉及的逻辑，而引用者这边的逻辑就稍微简单一些了，主要就是通过 &lt;code&gt;WeakReference&lt;&#x2F;code&gt; 这个类来实现的，比较简单，我们简单过一下就行。&lt;&#x2F;p&gt;
&lt;p&gt;Swift 中的 &lt;code&gt;weak&lt;&#x2F;code&gt; 变量经过 silgen 之后都会变成 &lt;code&gt;swift::swift_weakAssign&lt;&#x2F;code&gt; 调用，然后派发给 &lt;code&gt;WeakReference::nativeAssign&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;nativeAssign&lt;&#x2F;span&gt;&lt;span&gt;(HeapObject *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;newObject&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(newObject) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;objectUsesNativeSwiftReferenceCounting&lt;&#x2F;span&gt;&lt;span&gt;(newObject) &amp;amp;&amp;amp;
&lt;&#x2F;span&gt;&lt;span&gt;           &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;weak assign native with non-native new object&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;  }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 让被引用者构造 Side Table。
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; newSide =
&lt;&#x2F;span&gt;&lt;span&gt;    newObject ? newObject-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;refCounts&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;formWeakReference&lt;&#x2F;span&gt;&lt;span&gt;() : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;nullptr&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; newBits = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;WeakReferenceBits&lt;&#x2F;span&gt;&lt;span&gt;(newSide);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 喜闻乐见的 CAS。
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; oldBits = nativeValue.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;load&lt;&#x2F;span&gt;&lt;span&gt;(std::memory_order_relaxed);
&lt;&#x2F;span&gt;&lt;span&gt;  nativeValue.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;store&lt;&#x2F;span&gt;&lt;span&gt;(newBits, std::memory_order_relaxed);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span&gt;(oldBits.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;isNativeOrNull&lt;&#x2F;span&gt;&lt;span&gt;() &amp;amp;&amp;amp;
&lt;&#x2F;span&gt;&lt;span&gt;         &amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;weak assign native with non-native old object&lt;&#x2F;span&gt;&lt;span&gt;&amp;quot;);
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; 销毁原来对象的弱引用。
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;destroyOldNativeBits&lt;&#x2F;span&gt;&lt;span&gt;(oldBits);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;弱引用的访问就更简单了：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span&gt;HeapObject *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;nativeLoadStrongFromBits&lt;&#x2F;span&gt;&lt;span&gt;(WeakReferenceBits &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;auto&lt;&#x2F;span&gt;&lt;span&gt; side = bits.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;getNativeOrNull&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; side ? side-&amp;gt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;tryRetain&lt;&#x2F;span&gt;&lt;span&gt;() : &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;nullptr&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;到这里大家发现一个问题没有，被引用对象释放了为什么还能直接访问 Side Table？其实 Swift ABI 中 Side Table 的生命周期与对象是分离的，当强引用计数为 0 时，只有 &lt;code&gt;HeapObject&lt;&#x2F;code&gt; 被释放了。&lt;&#x2F;p&gt;
&lt;p&gt;只有所有的 &lt;code&gt;weak&lt;&#x2F;code&gt; 引用者都被释放了或相关变量被置 &lt;code&gt;nil&lt;&#x2F;code&gt; 后，Side Table 才能得以释放，详见：&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; style=&quot;background-color:#2b303b;color:#c0c5ce;&quot; class=&quot;language-cpp &quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span&gt;HeapObjectSideTableEntry::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;decrementWeak&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; FIXME: assertions
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; FIXME: optimize barriers
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt; cleanup = refCounts.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;decrementWeakShouldCleanUp&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(!cleanup)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Weak ref count is now zero. Delete the side table entry.
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; FREED -&amp;gt; DEAD
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;assert&lt;&#x2F;span&gt;&lt;span&gt;(refCounts.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;getUnownedCount&lt;&#x2F;span&gt;&lt;span&gt;() == &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;delete &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;this&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;所以即便使用了弱引用，也不能保证相关内存全部被释放，因为只要 &lt;code&gt;weak&lt;&#x2F;code&gt; 变量不被显式置 &lt;code&gt;nil&lt;&#x2F;code&gt;，Side Table 就会存在。而 ABI 中也有可以提升的地方，那就是如果访问弱引用变量时发现被引用对象已经释放，就将自己的弱引用销毁掉，避免之后重复无意义的 CAS 操作。当然 ABI 不做这个优化，我们也可以在 Swift 代码里做。:)&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zong-jie&quot;&gt;总结&lt;&#x2F;h2&gt;
&lt;p&gt;以上就是 Swift 弱引用机制实现方式的一个简单的分析，可见思路与 Objective-C runtime 还是很类似的，都采用与对象匹配的 Side Table 来维护引用计数。不同的地方就是 Objective-C 对象在内存布局中没有 Side Table 指针，而是通过一个全局的 &lt;code&gt;StripedMap&lt;&#x2F;code&gt; 来维护对象和 Side Table 之间的关系，效率没有 Swift 这么高。另外 Objective-C runtime 在对象释放时会将所有的 &lt;code&gt;__weak&lt;&#x2F;code&gt; 变量都 zero-out，而 Swift 并没有。&lt;&#x2F;p&gt;
&lt;p&gt;总的来说，Swift 的实现方式会稍微简单一些（虽然代码更复杂，Swift 团队追求更高的抽象）。第一次分析 Swift ABI，本文仅供参考，如果存在错误，欢迎大家勘正。感谢！&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
